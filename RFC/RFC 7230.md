
	하이퍼텍스트 전송 프로토콜 (HTTP/1.1) : 메세지 구문과 라우팅

* [page 1] 서문

	하이퍼 텍스트 전송 프로토콜(http)는 분산된, 협력적인 하이퍼 텍스트 정보 시스템을 위한 무상태 응용 프로그램 수준의 프로토콜입니다. 이 문서는 HTTP 구조에 대한 개요를 제공하고, 그와 관련된 용어, "http" 그리고 "https" 통합 자원 식별자 제도, HTTP/1.1 메세지 구문과 요구되는 파싱 처리를 정의하며 구현과 관련된 보안 사항을 기술합니다.

1. **Introduction**

	[page 5] 하이퍼텍스트 전송 프로토콜(HTTP)은 무상태 응용 프로그램 수준의 요청/응답 프로토콜로, 확장 가능한 의미론과 자기 서술적인 메시지 페이 로드(payload)를 사용하여 네트워크 기반 하이퍼 텍스트 정보 시스템과 유연한 상호 작용을 가능하게 합니다. 이 문서는 HTTP/1.1 사양을 형성하는 일련의 문서 중 첫 번째 문서입니다.

	1. 메세지 구문과 라우팅 (이 문서 RFC 7230)
	2. 의미론과 그 내용 (RFC 7231)
	3. 조건적 요청 (RFC 7232)
	4. 범위 요청 (RFC 7233)
	5. 캐싱 (RFC 7234)
	6. 인증 (RFC 7235)

  
	이 HTTP/1.1 사양은 RFC 2616 및 RFC 2145(HTTP 버전 지정에 대한)을 폐기합니다. 이 사양은 또한 이전에 RFC 2817에서 정의된 터널을 설정하기 위한 CONNECT의 사용을 업데이트하고, RFC 2818에서 비공식적으로 설명된 "https" URI 체계를 정의합니다.

	HTTP는 정보 시스템을 위한 범용 인터페이스 프로토콜입니다. 이는 서비스의 구현 세부 정보를 숨기기 위해 설계되어 클라이언트에게 제공되는 리소스의 유형과 독립적인, 일관된 인터페이스를 제공합니다. 마찬가지로 서버는 각 클라이언트의 목적을 알 필요가 없습니다. HTTP 요청은 특정 유형의 클라이언트나 사전에 정의된 응용 프로그램 단계의 일부로 연관되는 것이 아니라, 독립적으로 고려될 수 있습니다. **결과적으로, 이는 다양한 맥락에서 효과적으로 사용할 수 있는 프로토콜이며, 구현은 시간이 지남에 따라 독립적으로 진화할 수 있습니다.**

	HTTP는 또한 비-HTTP 정보 시스템과의 통신을 번역하기 위한 중개 프로토콜로 설계되었습니다. HTTP 프록시 및 게이트웨이는 다양한 프로토콜을 하이퍼텍스트 형식으로 변환하여 클라이언트가 HTTP 서비스와 동일한 방식으로 볼 수 있고 조작할 수 있도록 함으로써 대체 정보 서비스에 대한 액세스를 제공할 수 있습니다.

	이 유연성의 한 가지 결과는 프로토콜을 인터페이스 뒤에서 발생하는 측면으로 정의할 수 없다는 점입니다. 대신, 우리는 통신의 구문, 수신된 통신의 의도, 그리고 수신자의 예상 동작을 정의하는 데 제한됩니다. 통신이 독립적으로 고려된다면, 성공적인 동작은 서버가 제공하는 관찰 가능한 인터페이스에 해당 변경 사항이 반영되어야 합니다. 그러나 여러 클라이언트가 동시에 작업하고 때로는 상충하는 목적으로 작동할 수 있기 때문에, 이러한 변경 사항이 단일 응답의 범위를 벗어나서 관찰 가능하도록 요구할 수는 없습니다.
	
	이 문서는 HTTP에서 사용되거나 언급되는 아키텍처 요소를 설명하고, "http" 및 "https" URI 체계를(**scheme, 프로토콜**) 정의하며, 전체적인 네트워크 운영 및 연결 관리를 설명하며, HTTP 메시지 프레임 및 전달 요구 사항을 정의합니다. 우리의 목표는 메시지 의미론과 독립적인 HTTP 메시지 처리에 필요한 모든 메커니즘을 정의함으로써 메시지 파서 및 메시지 전달 중개자의 완전한 요구 사항 집합을 정의하는 것입니다.

	**1.1. 요청 표기법**

	- [page 6] "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", "OPTIONAL" 과 같은 단어는 다음과 같이 기술됩니다.

	- MUST: 이 단어 또는 "REQUIRED" 또는 "SHALL"이라는 용어는 해당 정의가 사양의 절대 요구사항임을 의미합니다.  
	- MUST NOT: 이 구문 또는 "SHALL NOT"라는 구문은 해당 정의가 사양의 절대적인 금지사항임을 의미합니다.
	- SHOULD: 이 단어 또는 "RECOMMENDED"라는 형용사는 특정 상황에서는 특정 항목을 무시할 수 있는 유효한 이유가 존재할 수 있지만, 다른 방식을 선택하기 전에 모든 영향을 이해하고 신중히 고려해야 함을 의미합니다.
	- SHOULD NOT: 이 구문 또는 "NOT RECOMMENDED"라는 구문은 특정 상황에서는 특정 동작이 허용되거나 심지어 유용할 수 있는 유효한 이유가 존재할 수 있지만, 모든 영향을 이해하고 사례를 신중히 고려해야 함을 의미합니다. 이 레이블로 설명된 동작을 구현하기 전에 해당 동작의 전체적인 영향을 이해하고 사례를 신중히 고려해야 합니다.
	- MAY: 이 단어 또는 "OPTIONAL"이라는 형용사는 항목이 실제로 선택 사항임을 의미합니다. 특정 시장 요구사항을 충족시키기 위해 또는 제품을 향상시키는 데 도움이 될 것으로 생각되기 때문에 한 공급업체는 해당 항목을 포함할 수 있으며, 다른 공급업체는 동일한 항목을 생략할 수 있습니다. 특정 옵션을 포함하지 않는 구현은 해당 옵션을 포함하는 다른 구현과 상호 운용될 수 있어야 합니다. 다만 기능이 제한될 수는 있습니다. 마찬가지로, 특정 옵션을 포함하는 구현은 해당 옵션을 포함하지 않는 다른 구현과 상호 운용될 수 있어야 합니다(물론 해당 옵션이 제공하는 기능은 제외됩니다).

	* 부합하는 기준과 에러 처리에 대한 고려는 섹션 2.5에 정의되어 있습니다.

	**1.2. 구문 표기**

	- 이 사양은 [RFC5234]의 확장된 Backus-Naur Form (ABNF) 표기법을 사용합니다. 이 표기법은 Section 7에서 정의된 목록 확장을 포함하고 있으며, '#' 연산자를 사용하여 쉼표로 구분된 목록을 간결하게 정의할 수 있도록 합니다. (이는 ** 연산자가 반복을 나타내는 방식과 유사합니다). 부록 B에는 모든 목록 연산자가 표준 ABNF 표기법으로 확장된 수집된 문법이 표시되어 있습니다.

	* 다음의 핵심 규칙은 [RFC5234], 부록 B.1에 정의된 대로 참조로 포함됩니다: ALPHA (문자), CR (캐리지 리턴), CRLF (CR LF), CTL (제어문자), DIGIT (10진수 0-9), DQUOTE (이중 인용부호), HEXDIG (16진수 0-9/A-F/a-f), HTAB (수평 탭), LF (줄 바꿈), OCTET (8비트 데이터 시퀀스), SP (공백), 그리고 VCHAR (가시적인 [USASCII] 문자).

	* 관례적으로, "obs-"로 접두사가 붙은 ABNF 규칙 이름은 역사적인 이유로 인해 나타나는 "폐기된" 문법 규칙을 나타냅니다.

2. **Architecture**

	HTTP는 World Wide Web (WWW) 아키텍처를 위해 만들어졌으며, 시간이 흐름에 따라 전 세계 하이퍼텍스트 시스템의 확장성 요구 사항을 지원하기 위해 발전해 왔습니다. 그 아키텍처의 많은 부분이 HTTP를 정의하는 용어와 구문 생성물에 반영되고 있습니다.

	**2.1 클라이언트 / 서버 메세징**

	 [page 7] HTTP는 신뢰할 수 있는 전송 또는 세션 계층의 "연결"(Section 6)을 통해 메시지(Section 3)를 교환하여 동작하는 무상태 요청/응답 프로토콜입니다. **HTTP "클라이언트"는 하나 이상의 HTTP 요청을 보내기 위해 서버와의 연결을 설정하는 프로그램입니다. HTTP "서버"는 HTTP 응답을 보내어 HTTP 요청을 처리하기 위해 연결을 수락하는 프로그램입니다.**
  
	"클라이언트"와 "서버"라는 용어는 이러한 프로그램들이 특정 연결에서 **수행하는 역할**에 대해서만 언급합니다. 동일한 프로그램이 어떤 연결에서는 클라이언트로 동작하고 어떤 연결에서는 서버로 동작할 수 있습니다. "유저 에이전트(UA)"라는 용어는 요청을 시작하는 다양한 클라이언트 프로그램을 의미하며, 브라우저, 스파이더 (웹 기반 로봇), 명령 줄 도구, 사용자 정의 애플리케이션 및 모바일 앱을 포함하지만 이에 국한되지는 않습니다. "원본 서버"라는 용어는 특정 대상 리소스에 대해 권위 있는 응답을 생성할 수 있는 프로그램을 가리킵니다. "송신자"와 "수신자"라는 용어는 각각 주어진 메시지를 송신하거나 수신하는 구현을 의미합니다.
 
	HTTP는 리소스의 대상을 나타내기 위해 Uniform Resource Identifier (URI) 표준 [RFC3986]을 사용하며, 리소스 간의 관계를 나타냅니다. 메시지는 인터넷 메일 [RFC5322]과 Multipurpose Internet Mail Extensions (MIME) [RFC2045]에서 사용되는 형식과 유사한 형식으로 전달됩니다. HTTP와 MIME 메시지의 차이점에 대해서는 [RFC7231]의 부록 A를 참조하십시오.
	
	대부분의 HTTP 통신은 URI로 식별된 어떤 리소스의 표현을 검색하기 위한 검색 요청(GET)으로 이루어집니다. 가장 간단한 경우에는 **유저 에이전트** **(UA)** 와 **원본 서버** (O) 간에 단일 양방향 연결( === )을 통해 이를 수행할 수 있습니다.

		   request >
       UA ======================================= O
                                   < response

	**클라이언트**는 요청 메시지 형식으로 서버에 HTTP 요청을 보냅니다. 이 요청 메시지는 **요청 라인(request-line)** 으로 시작하며, 이는 메서드, URI 및 프로토콜 버전 (Section 3.1.1)을 포함합니다. 이후에는 요청 수정자, 클라이언트 정보 및 표현 메타데이터를 포함하는 **헤더 필드** (Section 3.2)가 이어지고, 헤더 섹션의 끝을 나타내는 빈 줄이 옵니다. 마지막으로, **메시지 본문**에는 페이로드 본문이 포함될 수 있습니다 (있는 경우, Section 3.3).

	[page 8] **서버**는 클라이언트의 요청에 대해 하나 이상의 HTTP 응답 메시지를 보내어 응답합니다. 각 응답 메시지는 **상태 라인(status-line)** 으로 시작하며, 이는 프로토콜 버전, 성공 또는 오류 코드 및 텍스트 형식의 **이유 구문(reason phrase)** (Section 3.1.2)을 포함합니다. 이후에는 서버 정보, 리소스 메타데이터 및 표현 메타데이터를 포함하는 **헤더 필드 (Section 3.2)** 가 이어지고, 헤더 섹션의 끝을 나타내는 빈 줄이 옵니다. 마지막으로, **메시지 본문**에는 페이로드 본문이 포함될 수 있습니다 (있는 경우, Section 3.3).

	섹션 6.3에서 정의된대로

	다음 예제는 "[http://www.example.com/hello.txt](http://www.example.com/hello.txt)" URI에 대한 일반적인 GET 요청 (Section 4.3.1 of [RFC7231])에 대한 메시지 교환을 보여줍니다:
	
	**클라이언트 요청:**
	
	GET /hello.txt HTTP/1.1 
	User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3 
	Host: [www.example.com](http://www.example.com/) 
	Accept-Language: en, mi
	
	**서버 응답:**
	
	HTTP/1.1 200 OK 
	Date: Mon, 27 Jul 2009 12:28:53 GMT 
	Server: Apache 
	Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT 
	ETag: "34aa387-d-1568eb00" 
	Accept-Ranges: bytes 
	Content-Length: 51 
	Vary: Accept-Encoding 
	Content-Type: text/plain
	
	Hello World! My payload includes a trailing CRLF.

	**2.2. 구현 다양성**
	
	HTTP의 설계를 고려할 때, 모든 유저 에이전트가 일반적인 웹 브라우저이고 모든 출처 서버가 대형 공개 웹사이트인 것으로 생각하기 쉽습니다. 그러나 실제로는 그렇지 않습니다. 일반적인 HTTP 유저 에이전트에는 가전제품, 스테레오, 저울, 펌웨어 업데이트 스크립트, 명령줄 프로그램, 모바일 앱 및 다양한 모양과 크기의 통신 장치 등이 포함됩니다. 마찬가지로, 일반적인 HTTP 출처 서버에는 홈 자동화 장치, 구성 가능한 네트워킹 구성 요소, 사무 기기, 자율 로봇, 뉴스 피드, 교통 카메라, 광고 선택기 및 비디오 전송 플랫폼이 포함됩니다.

	[page 9] "유저 에이전트"라는 용어는 요청이 발생할 때 인간 사용자가 소프트웨어 에이전트와 직접 상호작용하는 것을 의미하지 않습니다. 많은 경우 유저 에이전트는 백그라운드에서 실행되거나 구성되어 나중에 결과를 검사하기 위해 저장됩니다 (또는 흥미로운 또는 오류가 될 수 있는 결과의 일부분만 저장됩니다). 예를 들어, 스파이더는 일반적으로 시작 URI를 지정하고 웹을 탐색하는 동안 특정 동작을 따르도록 구성됩니다.

	HTTP의 구현 다양성은 모든 유저 에이전트가 사용자에게 대화식 제안을 제공하거나 보안 또는 개인 정보 보호에 대한 적절한 경고를 제공할 수 있는 것은 아니라는 것을 의미합니다. 이 명세에서 오류를 사용자에게 보고해야 하는 몇 가지 경우에는 해당 보고가 오류 콘솔이나 로그 파일에서만 관찰될 수 있는 것으로 허용됩니다. 마찬가지로, 자동화된 동작을 진행하기 전에 사용자로부터 확인이 필요한 요구 사항은 사전 구성 선택, 실행 시 옵션 또는 해당 위험한 동작을 피하는 간단한 조치로 충족될 수 있습니다. 확인은 특정 사용자 인터페이스나 정상 처리의 중단을 의미하지 않으며, 사용자가 이미 해당 선택을 했다면 정상 처리가 진행될 수 있습니다.

	**2.3 중재자들**

	  HTTP는 연결 체인을 통해 중개자를 사용하여 요청을 충족시키는 기능을 제공합니다. HTTP 중개자에는 프록시(proxy), 게이트웨이(gateway) 및 터널(tunnel)의 세 가지 일반적인 형태가 있습니다. 경우에 따라 단일 중개자가 각 요청의 성격에 따라 원 서버, 프록시, 게이트웨이 또는 터널로 작동할 수 있습니다.
         ->       ->      ->      ->
	 UA ===== A ===== B ===== C ===== O
	      <-       <-      <-      <-
	      
	위의 도표는 유저 에이전트와 원 서버 사이에 A, B, C라는 세 개의 중개자를 보여줍니다. 전체 체인을 통과하는 요청 또는 응답 메시지는 네 개의 별개의 연결을 통과합니다. 일부 HTTP 통신 옵션은 가장 가까운 터널이 아닌 이웃과의 연결에만 적용되거나 체인의 끝점에만 적용되거나 체인 전체의 모든 연결에 적용될 수 있습니다. 그림은 선형적이지만 각 참가자는 여러 개의 동시 통신에 참여할 수 있습니다. 예를 들어, B는 A 외에도 다른 클라이언트로부터 요청을 받거나 C 이외의 서버로 요청을 전달하면서 A의 요청을 처리하는 동시에 여러 개의 통신을 수행할 수 있습니다. 마찬가지로 나중의 요청은 로드 밸런싱을 위한 동적 구성에 따라 다른 연결 경로를 통해 전송될 수 있습니다.

	[page 10] **"Upstream"** 과 **"downstream"** 이라는 용어는 메시지의 흐름과 관련하여 방향성 요구사항을 설명하는 데 사용됩니다. 모든 메시지는 "upstream"에서 "downstream"으로 흐릅니다. "Inbound"와 "outbound"라는 용어는 요청 경로와 관련하여 방향성 요구사항을 설명하는 데 사용됩니다. "Inbound"는 원 서버 쪽으로의 방향을 의미하며, 메시지가 처리를 위해 서버 쪽으로 이동하는 것을 나타냅니다. 반면에 "outbound"는 유저 에이전트 쪽으로의 방향을 의미하며, 메시지가 유저 에이전트 쪽으로 이동하여 소비되거나 표시되는 것을 나타냅니다.

	"**프록시(proxy)**"는 주로 로컬 설정 규칙을 경유하여, 클라이언트에 의해 선택되는 메시지 전달 에이전트로 일부 유형의 절대 URI를 요청 받고 HTTP 인터페이스를 통해 해당 요청을 만족시키기 위해 번역을 시도합니다. 일부 번역은 최소한으로 이루어지며, "http" URI에 대한 프록시 요청과 같은 경우입니다. 반면에 다른 요청은 완전히 다른 응용 계층 프로토콜로의 번역이 필요할 수도 있습니다. 프록시는 종종 보안, 주석 서비스 또는 공유 캐싱을 위해 조직의 HTTP 요청을 공통 중개자를 통해 그룹화하는 데 사용됩니다. 일부 프록시는 전달되는 동안 선택된 메시지나 페이로드에 변형을 적용하는 것이 설명된 섹션 5.7.2에서 설명된 대로 설계될 수 있습니다.
	![[local_configuration_rule.png]]

	 "**게이트웨이(gateway)**" (또는 "리버스 프록시")는 외부 연결("outbound")의 출발지 서버 역할을 하는 중개자로, 받은 요청을 번역하여 내부로 전달합니다. 게이트웨이는 종종 레거시 시스템이나 신뢰할 수 없는 정보 서비스를 캡슐화하거나, "가속기" 캐싱을 통해 서버 성능을 향상시키는 데 사용되며, HTTP 서비스를 여러 기기에 분할하거나 부하 분산을 가능하게 합니다.

	모든 원본 서버에 적용되는 HTTP 요구사항은 게이트웨이의 외부 통신에도 적용됩니다. 게이트웨이는 원하는 프로토콜을 사용하여 인바운드 서버와 통신하며, 이는 이 명세의 범위를 벗어나는 HTTP에 대한 사적인 확장을 포함할 수 있습니다. 그러나 HTTP-to-HTTP 게이트웨이가 타사 HTTP 서버와 상호 운용하려는 경우에는 게이트웨이의 인바운드 연결에 대한 사용자 에이전트 요구사항을 준수하는 것이 좋습니다.

	"**터널(tunnel)**"은 메시지를 변경하지 않으면서 두 연결 사이에서 블라인드 중계 역할을 수행합니다. 터널은 일단 활성화되면 HTTP 통신의 일부로 간주되지는 않지만, 그 자체는 HTTP 요청에 의해 시작될 수 있습니다. 터널은 양측의 연속적인 통신이 끝날 때 종료됩니다. 터널은 공유 방화벽 프록시를 통해 기밀 통신을 설정하기 위해 전송 계층 보안(TLS, [RFC5246])을 사용할 때와 같이 중개자를 통해 가상 연결을 확장하는 데 사용됩니다.

	[page 11] 앞서 언급한 중개자에 대한 분류는 HTTP 통신의 참여자로서 작동하는 중개자만을 고려합니다. 그러나 메시지 발송자의 지식이나 허락 없이 HTTP 트래픽을 필터링하거나 리디렉션하는 등 네트워크 프로토콜 스택의 하위 계층에서 작동하는 중개자도 존재합니다. 이러한 네트워크 중개자는 프로토콜 수준에서 중간자 공격과 구별할 수 없으며, 종종 HTTP 의미론을 잘못 위반하여 보안 결함이나 상호 운용성 문제를 야기할 수 있습니다.

	예를 들어, "interception proxy" [RFC3040] (일반적으로 "transparent proxy" [RFC1919] 또는 "captive portal"로도 알려짐)는 클라이언트에 의해 선택되지 않기 때문에 HTTP 프록시와는 다릅니다. 대신, 인터셉션 프록시는 나가는 TCP 포트 80 패킷(가끔 다른 일반적인 포트 트래픽도)을 필터링하거나 리디렉션합니다. 인터셉션 프록시는 일반적으로 공공 네트워크 접근 지점에서 찾을 수 있으며, 비로컬 인터넷 서비스 사용 전에 계정 구독을 강제하는 수단으로 사용되거나, 기업 방화벽에서 네트워크 사용 정책을 강제하는 용도로 사용됩니다.
	  
	HTTP는 무상태 프로토콜로 정의되어 있으며, 그것은 각각의 요청 메시지가 독립적으로 이해될 수 있다는 의미입니다. 많은 구현이 프록시된 연결을 재사용하거나 여러 서버에 동적으로 요청을 로드 밸런싱하기 위해 HTTP의 상태 없는 디자인에 의존합니다. 따라서 서버는 연결이 보안되고 특정한 에이전트에게 속한 것인 경우를 제외하고는 동일한 연결에서 온 두 개의 요청이 동일한 사용자 에이전트에 의한 것으로 가정해서는 안 됩니다(**"MUST NOT"**). 비표준 HTTP 확장 (예: [RFC4559]) 중 일부는 이 요구사항을 위반하여 보안 및 상호 운용성 문제를 야기하는 것으로 알려져 있습니다.

	**2.4 캐시**

	"캐시(cache)"는 이전 응답 메시지의 로컬 저장소와 해당 메시지의 저장, 검색 및 삭제를 제어하는 하위 시스템입니다. 캐시는 캐시 가능한 응답을 저장하여 이후 동등한 요청에 대한 응답 시간과 네트워크 대역폭 소비를 줄입니다. 클라이언트나 서버는 캐시를 사용할 수 있으나, 서버가 터널로 동작하는 동안에는 캐시를 사용할 수 없습니다.

	[page 12] 캐시의 효과는 체인 상에 있는 참여자 중 하나가 해당 요청에 적용 가능한 캐시된 응답을 가지고 있을 경우, 요청/응답 체인이 단축된다는 것입니다. 다음은 UA 또는 A에 의해 캐시되지 않은 요청에 대해 B가 O(를 통해 C를 거쳐)의 이전 응답에 대한 캐시된 복사본을 가지고 있는 경우의 결과적인 체인을 보여줍니다.

     ---->          ---->	
	UA =========== A =========== B - - - - - - C - - - - - - 
			  <--           <--

	응답은 캐시가 해당 응답 메시지의 복사본을 저장하여 이후 요청에 대한 응답으로 사용할 수 있는 경우 "캐시 가능(cacheable)"하다고 할 수 있습니다. 응답이 캐시 가능하더라도 클라이언트나 원 서버에서 해당 캐시된 응답을 특정 요청에 사용할 때 추가적인 제약 사항이 있을 수 있습니다. 캐시 동작 및 캐시 가능한 응답에 대한 HTTP 요구사항은 [RFC7234]의 섹션 2에서 정의되어 있습니다.

	세계적으로와 대규모 조직 내에서 다양한 아키텍처와 캐시 구성이 웹 전반에 걸쳐 배치되어 있습니다. 이에는 대양간 대역폭을 절약하기 위한 국가적인 프록시 캐시의 계층 구조, 캐시 항목을 브로드캐스트하거나 멀티캐스트하는 협업 시스템, 오프라인이나 높은 지연 환경에서 사용하기 위한 미리 가져온 캐시 항목의 아카이브 등이 포함됩니다.

	**2.5 표준 및 에러 처리**

	이 사양은 HTTP 통신의 참여자 역할에 따른 준수 기준을 대상으로 합니다. 따라서 요구 사항에 의해 제한되는 동작에 따라 발신자, 수신자, 클라이언트, 서버, 사용자 에이전트, 중개자, 출처 서버, 프록시, 게이트웨이 또는 캐시에 HTTP 요구 사항이 부여됩니다. 단일 통신의 범위를 벗어나는 경우 구현, 리소스 소유자 및 프로토콜 요소 등에 추가 (사회적) 요구 사항이 부여됩니다.

	"generate"라는 동사는 요구 사항이 프로토콜 요소를 생성하는 것과 단순히 수신한 요소를 하류로 전달하는 것을 구분하는 경우 "send" 대신 사용됩니다.

	HTTP에 참여하는 역할과 관련된 모든 요구 사항을 준수하는 경우 구현은 준수되는 것으로 간주됩니다.
	
	준수는 프로토콜 요소의 구문 및 의미를 포함합니다. 발신자는 자신이 거짓으로 알고 있는 의미를 전달하는 프로토콜 요소를 생성해서는 안 됩니다. 발신자는 해당 ABNF 규칙에 의해 정의된 문법과 일치하지 않는 프로토콜 요소를 생성해서는 안 됩니다. 주어진 메시지 내에서 발신자는 다른 역할의 참여자만이 생성할 수 있는 프로토콜 요소나 구문 대안을 생성해서는 안 됩니다 (즉, 발신자가 해당 메시지에 대해 가지지 않은 역할).

	수신된 프로토콜 요소가 구문 분석될 때, 수신자는 수신자의 역할에 적용 가능하고 해당 ABNF 규칙에 정의된 문법과 일치하는 합리적인 길이의 모든 값을 구문 분석할 수 있어야 합니다. 그러나 수신된 프로토콜 요소 중 일부는 구문 분석되지 않을 수도 있습니다. 예를 들어, 메시지를 전달하는 중개자는 헤더 필드를 일반적인 필드 이름과 필드 값 구성 요소로 구문 분석할 수 있지만, 필드 값 내에서 추가로 구문 분석하지 않고 헤더 필드를 전달할 수도 있습니다.

	[page 13] HTTP는 많은 프로토콜 요소에 대해 특정 길이 제한을 갖고 있지 않습니다. 이는 적절한 길이가 배치 환경과 구현의 목적에 따라 크게 달라질 수 있기 때문입니다. 따라서 발신자와 수신자 간의 상호 운용성은 각 프로토콜 요소에 대해 어떤 길이가 합리적인지에 대한 공유된 기대에 따라 달려있습니다. 게다가, 몇 가지 프로토콜 요소에 대해 일반적으로 합리적인 길이로 인식되는 것은 HTTP 사용의 지난 20년 동안 변경되어왔으며, 미래에도 계속 변화할 것으로 예상됩니다.

	최소한으로, 수신자는 다른 메시지에서 동일한 프로토콜 요소에 대해 생성하는 값과 동일한 길이 이상의 프로토콜 요소 길이를 구문 분석하고 처리할 수 있어야 합니다(**"MUST"**). 예를 들어, 자체 자원에 대해 매우 긴 URI 참조를 발행하는 출처 서버는 해당 참조를 요청 대상으로 수신받을 때 구문 분석하고 처리할 수 있어야 합니다.

	수신자는 수신한 프로토콜 요소를 이 사양에 의해 정의된 의미에 따라 해석해야 합니다(**"MUST"**). 이 사양의 확장을 포함하여 의미에 의해 암시되는 것을 발신자가 잘못 구현한다고 판단하지 않은 한 (경험 또는 구성을 통해), 예외가 아닌 경우 프로토콜 요소를 사용자 정의해야 합니다. 예를 들어, 특정 콘텐츠 인코딩을 수신할 경우 실패하는 특정 구현 버전을 나타내는 User-Agent 헤더 필드 검사를 통해 Accept-Encoding 헤더 필드의 내용을 무시할 수 있습니다.
	
	특별히 언급되지 않은 경우, 수신자는 잘못된 구조에서 사용 가능한 프로토콜 요소를 복구하려고 시도할 수 있습니다. HTTP는 프로토콜의 다양한 응용에 따라 다른 오류 처리 전략이 필요하기 때문에, 보안에 직접적인 영향을 미치는 경우를 제외하고는 특정 오류 처리 메커니즘을 정의하지 않습니다. 예를 들어, 웹 브라우저는 ABNF에 따라 구문 분석되지 않는 경우 Location 헤더 필드에서 투명하게 복구하려 할 수 있으나, 시스템 제어 클라이언트는 오류 복구의 어떤 형태도 위험하다고 간주할 수 있습니다.

	**2.6 프로토콜 버전 관리**
	
	HTTP는 프로토콜의 버전을 나타내기 위해 "<major>.<minor>" 번호 체계를 사용합니다. 이 명세서는 버전 "1.1"을 정의합니다. 프로토콜 버전은 해당 버전의 HTTP 명세서에 기술된 요구 사항 집합에 대한 발신자의 준수를 나타냅니다.

	HTTP 메시지의 버전은 메시지의 첫 번째 줄에 있는 HTTP-version 필드로 나타냅니다. HTTP-version은 대소문자를 구분합니다.
	
	HTTP-version  = HTTP-name "/" DIGIT "." DIGIT
	HTTP-name     = %x48.54.54.50 ; "HTTP", 대소문자를 구분합니다.

	HTTP 버전 번호는 "." (점 또는 소수점)으로 구분된 두 개의 십진 숫자로 구성됩니다. 첫 번째 숫자("주 버전")는 HTTP 메시징 구문을 나타내며, 두 번째 숫자("부 버전")는 발신자가 준수하고 이해할 수 있는 주 버전 내에서의 가장 높은 부 버전을 나타냅니다. 부 버전은 발신자의 통신 능력을 알리며, 발신자가 프로토콜의 하위 호환성 부분 집합만 사용하는 경우에도 더 발전된 기능을 응답(서버에서)이나 미래의 요청(클라이언트에서)에서 사용할 수 있다는 것을 수신자에게 알려줍니다.
  
	HTTP/1.1 메시지가 HTTP/1.0 수신자 [RFC1945] 또는 버전이 알려지지 않은 수신자에게 전송될 때, HTTP/1.1 메시지는 최신 기능을 무시하면 유효한 HTTP/1.0 메시지로 해석될 수 있도록 구성됩니다. 이 명세서는 수신자 버전에 대한 일부 새로운 기능의 요구 사항을 설정하여 준수하는 발신자가 HTTP/1.1을 지원하는 수신자를 확인하기 전까지 호환 가능한 기능만 사용하도록 합니다. 이는 구성 또는 메시지 수신을 통해 수신자가 HTTP/1.1을 지원하는 것을 확인하기 전까지입니다.
  
	같은 주 버전의 부 버전 간에 헤더 필드의 해석은 변경되지 않지만, 해당 필드가 없을 때 수신자의 기본 동작은 변경될 수 있습니다. 특별히 명시되지 않은 경우, HTTP/1.1에서 정의된 헤더 필드는` 모든 HTTP/1.x 버전에 대해 정의됩니다. 특히, Host 및 Connection 헤더 필드는 HTTP/1.1의 준수 여부와 관계없이 모든 HTTP/1.x 구현에서 구현되어야 합니다.
  
	새로운 헤더 필드는 정의된 의미가 인식하지 못하는 수신자에게 안전하게 무시될 수 있도록 허용되는 경우에는 프로토콜 버전을 변경하지 않고도 도입될 수 있습니다. 헤더 필드의 확장성은 섹션 3.2.1에서 논의됩니다.

	HTTP 메시지를 처리하는 중개자(즉, 터널로 동작하지 않는 모든 중개자)은 전달된 메시지에서 자체적인 HTTP-version을 보내야 합니다("**MUST**"). 다시 말해, 중개자는 메시지의 첫 번째 줄을 맹목적으로 전달하는 것이 아니라, 해당 중개자가 수신 및 송신 메시지에 대해 준수하는 버전과 일치하는지 확인한 후에 메시지를 전달해야 합니다. HTTP-version을 재작성하지 않고 HTTP 메시지를 전달하는 것은, 하위 수신자가 메시지 전송자의 버전을 사용하여 이후 통신에 안전하게 사용할 수 있는 기능을 결정할 때 통신 오류가 발생할 수 있습니다.
  
	[page 15] 클라이언트는 알고 있는 경우, 서버가 지원하는 가장 높은 버전보다 높지 않은 주 버전에 해당하고 클라이언트가 준수하는 가장 높은 버전과 동일한 요청 버전을 보내는 것이 좋습니다. 클라이언트는 자신이 준수하지 않는 버전을 보내서는 안 됩니다.