
link : https://datatracker.ietf.org/doc/html/rfc7230

	하이퍼텍스트 전송 프로토콜 (HTTP/1.1) : 메세지 구문과 라우팅

* [page 1] 서문

	하이퍼 텍스트 전송 프로토콜(http)는 분산된, 협력적인 하이퍼 텍스트 정보 시스템을 위한 무상태 응용 프로그램 수준의 프로토콜입니다. 이 문서는 HTTP 구조에 대한 개요를 제공하고, 그와 관련된 용어, "http" 그리고 "https" 통합 자원 식별자 제도, HTTP/1.1 메세지 구문과 요구되는 파싱 처리를 정의하며 구현과 관련된 보안 사항을 기술합니다.

1) **Introduction**

	[page 5] 하이퍼텍스트 전송 프로토콜(HTTP)은 무상태 응용 프로그램 수준의 요청/응답 프로토콜로, 확장 가능한 의미론과 자기 서술적인 메시지 페이 로드(payload)를 사용하여 네트워크 기반 하이퍼 텍스트 정보 시스템과 유연한 상호 작용을 가능하게 합니다. 이 문서는 HTTP/1.1 사양을 형성하는 일련의 문서 중 첫 번째 문서입니다.

	1. 메세지 구문과 라우팅 (이 문서 RFC 7230)
	2. 의미론과 그 내용 (RFC 7231)
	3. 조건적 요청 (RFC 7232)
	4. 범위 요청 (RFC 7233)
	5. 캐싱 (RFC 7234)
	6. 인증 (RFC 7235)

	이 HTTP/1.1 사양은 RFC 2616 및 RFC 2145(HTTP 버전 지정에 대한)을 폐기합니다. 이 사양은 또한 이전에 RFC 2817에서 정의된 터널을 설정하기 위한 CONNECT의 사용을 업데이트하고, RFC 2818에서 비공식적으로 설명된 "https" URI 스킴을 정의합니다.

	HTTP는 정보 시스템을 위한 범용 인터페이스 프로토콜입니다. 이는 서비스의 구현 세부 정보를 숨기기 위해 설계되어 클라이언트에게 제공되는 리소스의 유형과 독립적인, 일관된 인터페이스를 제공합니다. 마찬가지로 서버는 각 클라이언트의 목적을 알 필요가 없습니다. HTTP 요청은 특정 유형의 클라이언트나 사전에 정의된 응용 프로그램 단계의 일부로 연관되는 것이 아니라, 독립적으로 고려될 수 있습니다. **결과적으로, 이는 다양한 맥락에서 효과적으로 사용할 수 있는 프로토콜이며, 구현은 시간이 지남에 따라 독립적으로 진화할 수 있습니다.**

	HTTP는 또한 비-HTTP 정보 시스템과의 통신을 번역하기 위한 중개 프로토콜로 설계되었습니다. HTTP 프록시 및 게이트웨이는 다양한 프로토콜을 하이퍼텍스트 형식으로 변환하여 클라이언트가 HTTP 서비스와 동일한 방식으로 볼 수 있고 조작할 수 있도록 함으로써 대체 정보 서비스에 대한 액세스를 제공할 수 있습니다.

	이 유연성의 한 가지 결과는 프로토콜을 인터페이스 뒤에서 발생하는 측면으로 정의할 수 없다는 점입니다. 대신, 우리는 통신의 구문, 수신된 통신의 의도, 그리고 수신자의 예상 동작을 정의하는 데 제한됩니다. 통신이 독립적으로 고려된다면, 성공적인 동작은 서버가 제공하는 관찰 가능한 인터페이스에 해당 변경 사항이 반영되어야 합니다. 그러나 여러 클라이언트가 동시에 작업하고 때로는 상충하는 목적으로 작동할 수 있기 때문에, 이러한 변경 사항이 단일 응답의 범위를 벗어나서 관찰 가능하도록 요구할 수는 없습니다.
	
	이 문서는 HTTP에서 사용되거나 언급되는 아키텍처 요소를 설명하고, "http" 및 "https" URI 스킴을(**scheme, 프로토콜**) 정의하며, 전체적인 네트워크 운영 및 연결 관리를 설명하며, HTTP 메시지 프레임 및 전달 요구 사항을 정의합니다. 우리의 목표는 메시지 의미론과 독립적인 HTTP 메시지 처리에 필요한 모든 메커니즘을 정의함으로써 메시지 파서 및 메시지 전달 중개자의 완전한 요구 사항 집합을 정의하는 것입니다.

	**1.1. 요청 표기법**

	 - [page 6] "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", "OPTIONAL" 과 같은 단어는 다음과 같이 기술됩니다.

	 - MUST: 이 단어 또는 "REQUIRED" 또는 "SHALL"이라는 용어는 해당 정의가 사양의 절대 요구사항임을 의미합니다.  
	 - MUST NOT: 이 구문 또는 "SHALL NOT"라는 구문은 해당 정의가 사양의 절대적인 금지사항임을 의미합니다.
	 - SHOULD: 이 단어 또는 "RECOMMENDED"라는 형용사는 특정 상황에서는 특정 항목을 무시할 수 있는 유효한 이유가 존재할 수 있지만, 다른 방식을 선택하기 전에 모든 영향을 이해하고 신중히 고려해야 함을 의미합니다.
	 - SHOULD NOT: 이 구문 또는 "NOT RECOMMENDED"라는 구문은 특정 상황에서는 특정 동작이 허용되거나 심지어 유용할 수 있는 유효한 이유가 존재할 수 있지만, 모든 영향을 이해하고 사례를 신중히 고려해야 함을 의미합니다. 이 레이블로 설명된 동작을 구현하기 전에 해당 동작의 전체적인 영향을 이해하고 사례를 신중히 고려해야 합니다.
	 - MAY: 이 단어 또는 "OPTIONAL"이라는 형용사는 항목이 실제로 선택 사항임을 의미합니다. 특정 시장 요구사항을 충족시키기 위해 또는 제품을 향상시키는 데 도움이 될 것으로 생각되기 때문에 한 공급업체는 해당 항목을 포함할 수 있으며, 다른 공급업체는 동일한 항목을 생략할 수 있습니다. 특정 옵션을 포함하지 않는 구현은 해당 옵션을 포함하는 다른 구현과 상호 운용될 수 있어야 합니다. 다만 기능이 제한될 수는 있습니다. 마찬가지로, 특정 옵션을 포함하는 구현은 해당 옵션을 포함하지 않는 다른 구현과 상호 운용될 수 있어야 합니다(물론 해당 옵션이 제공하는 기능은 제외됩니다).

	 * 부합하는 기준과 에러 처리에 대한 고려는 섹션 2.5에 정의되어 있습니다.

	**1.2. 구문 표기**

	 - 이 사양은 [RFC5234]의 확장된 Backus-Naur Form (ABNF) 표기법을 사용합니다. 이 표기법은 Section 7에서 정의된 목록 확장을 포함하고 있으며, '#' 연산자를 사용하여 쉼표로 구분된 목록을 간결하게 정의할 수 있도록 합니다. (이는 ** 연산자가 반복을 나타내는 방식과 유사합니다). 부록 B에는 모든 목록 연산자가 표준 ABNF 표기법으로 확장된 수집된 문법이 표시되어 있습니다.

	 * 다음의 핵심 규칙은 [RFC5234], 부록 B.1에 정의된 대로 참조로 포함됩니다: ALPHA (문자), CR (캐리지 리턴), CRLF (CR LF), CTL (제어문자), DIGIT (10진수 0-9), DQUOTE (이중 인용부호), HEXDIG (16진수 0-9/A-F/a-f), HTAB (수평 탭), LF (줄 바꿈), OCTET (8비트 데이터 시퀀스), SP (공백), 그리고 VCHAR (가시적인 [USASCII] 문자).

	 * 관례적으로, "obs-"로 접두사가 붙은 ABNF 규칙 이름은 역사적인 이유로 인해 나타나는 "폐기된" 문법 규칙을 나타냅니다.

2) **Architecture**

	HTTP는 World Wide Web (WWW) 아키텍처를 위해 만들어졌으며, 시간이 흐름에 따라 전 세계 하이퍼텍스트 시스템의 확장성 요구 사항을 지원하기 위해 발전해 왔습니다. 그 아키텍처의 많은 부분이 HTTP를 정의하는 용어와 구문 생성물에 반영되고 있습니다.

	**2.1 클라이언트 / 서버 메세징**

	 [page 7] HTTP는 신뢰할 수 있는 전송 또는 세션 계층의 "연결"(Section 6)을 통해 메시지(Section 3)를 교환하여 동작하는 무상태 요청/응답 프로토콜입니다. **HTTP "클라이언트"는 하나 이상의 HTTP 요청을 보내기 위해 서버와의 연결을 설정하는 프로그램입니다. HTTP "서버"는 HTTP 응답을 보내어 HTTP 요청을 처리하기 위해 연결을 수락하는 프로그램입니다.**
  
	 "클라이언트"와 "서버"라는 용어는 이러한 프로그램들이 특정 연결에서 **수행하는 역할**에 대해서만 언급합니다. 동일한 프로그램이 어떤 연결에서는 클라이언트로 동작하고 어떤 연결에서는 서버로 동작할 수 있습니다. "유저 에이전트(UA)"라는 용어는 요청을 시작하는 다양한 클라이언트 프로그램을 의미하며, 브라우저, 스파이더 (웹 기반 로봇), 명령 줄 도구, 사용자 정의 애플리케이션 및 모바일 앱을 포함하지만 이에 국한되지는 않습니다. "원본 서버"라는 용어는 특정 대상 리소스에 대해 권위 있는 응답을 생성할 수 있는 프로그램을 가리킵니다. "송신자"와 "수신자"라는 용어는 각각 주어진 메시지를 송신하거나 수신하는 구현을 의미합니다.
 
	 HTTP는 리소스의 대상을 나타내기 위해 Uniform Resource Identifier (URI) 표준 [RFC3986]을 사용하며, 리소스 간의 관계를 나타냅니다. 메시지는 인터넷 메일 [RFC5322]과 Multipurpose Internet Mail Extensions (MIME) [RFC2045]에서 사용되는 형식과 유사한 형식으로 전달됩니다. HTTP와 MIME 메시지의 차이점에 대해서는 [RFC7231]의 부록 A를 참조하십시오.
	
	 대부분의 HTTP 통신은 URI로 식별된 어떤 리소스의 표현을 검색하기 위한 검색 요청(GET)으로 이루어집니다. 가장 간단한 경우에는 **유저 에이전트** **(UA)** 와 **원본 서버** (O) 간에 단일 양방향 연결( === )을 통해 이를 수행할 수 있습니다.

		    request >
        UA ======================================= O
                                   < response

	 **클라이언트**는 요청 메시지 형식으로 서버에 HTTP 요청을 보냅니다. 이 요청 메시지는 **요청 라인(request-line)** 으로 시작하며, 이는 메서드, URI 및 프로토콜 버전 (Section 3.1.1)을 포함합니다. 이후에는 요청 수정자, 클라이언트 정보 및 표현 메타데이터를 포함하는 **헤더 필드** (Section 3.2)가 이어지고, 헤더 섹션의 끝을 나타내는 빈 줄이 옵니다. 마지막으로, **메시지 본문**에는 페이로드 본문이 포함될 수 있습니다 (있는 경우, Section 3.3).

	 [page 8] **서버**는 클라이언트의 요청에 대해 하나 이상의 HTTP 응답 메시지를 보내어 응답합니다. 각 응답 메시지는 **상태 라인(status-line)** 으로 시작하며, 이는 프로토콜 버전, 성공 또는 오류 코드 및 텍스트 형식의 **이유 구문(reason phrase)** (Section 3.1.2)을 포함합니다. 이후에는 서버 정보, 리소스 메타데이터 및 표현 메타데이터를 포함하는 **헤더 필드 (Section 3.2)** 가 이어지고, 헤더 섹션의 끝을 나타내는 빈 줄이 옵니다. 마지막으로, **메시지 본문**에는 페이로드 본문이 포함될 수 있습니다 (있는 경우, Section 3.3).

	 섹션 6.3에서 정의된대로

	 다음 예제는 "[http://www.example.com/hello.txt](http://www.example.com/hello.txt)" URI에 대한 일반적인 GET 요청 (Section 4.3.1 of [RFC7231])에 대한 메시지 교환을 보여줍니다:
	
	 **클라이언트 요청:**
	
	 GET /hello.txt HTTP/1.1 
	 User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3 
	 Host: [www.example.com](http://www.example.com/) 
	 Accept-Language: en, mi
	
	 **서버 응답:**
	
	 HTTP/1.1 200 OK 
	 Date: Mon, 27 Jul 2009 12:28:53 GMT 
	 Server: Apache 
	 Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT 
	 ETag: "34aa387-d-1568eb00" 
	 Accept-Ranges: bytes 
	 Content-Length: 51 
	 Vary: Accept-Encoding 
	 Content-Type: text/plain
	
	 Hello World! My payload includes a trailing CRLF.

	**2.2 구현 다양성**
	
	 HTTP의 설계를 고려할 때, 모든 유저 에이전트가 일반적인 웹 브라우저이고 모든 출처 서버가 대형 공개 웹사이트인 것으로 생각하기 쉽습니다. 그러나 실제로는 그렇지 않습니다. 일반적인 HTTP 유저 에이전트에는 가전제품, 스테레오, 저울, 펌웨어 업데이트 스크립트, 명령줄 프로그램, 모바일 앱 및 다양한 모양과 크기의 통신 장치 등이 포함됩니다. 마찬가지로, 일반적인 HTTP 출처 서버에는 홈 자동화 장치, 구성 가능한 네트워킹 구성 요소, 사무 기기, 자율 로봇, 뉴스 피드, 교통 카메라, 광고 선택기 및 비디오 전송 플랫폼이 포함됩니다.

	 [page 9] "유저 에이전트"라는 용어는 요청이 발생할 때 인간 사용자가 소프트웨어 에이전트와 직접 상호작용하는 것을 의미하지 않습니다. 많은 경우 유저 에이전트는 백그라운드에서 실행되거나 구성되어 나중에 결과를 검사하기 위해 저장됩니다 (또는 흥미로운 또는 오류가 될 수 있는 결과의 일부분만 저장됩니다). 예를 들어, 스파이더는 일반적으로 시작 URI를 지정하고 웹을 탐색하는 동안 특정 동작을 따르도록 구성됩니다.

	 HTTP의 구현 다양성은 모든 유저 에이전트가 사용자에게 대화식 제안을 제공하거나 보안 또는 개인 정보 보호에 대한 적절한 경고를 제공할 수 있는 것은 아니라는 것을 의미합니다. 이 명세에서 오류를 사용자에게 보고해야 하는 몇 가지 경우에는 해당 보고가 오류 콘솔이나 로그 파일에서만 관찰될 수 있는 것으로 허용됩니다. 마찬가지로, 자동화된 동작을 진행하기 전에 사용자로부터 확인이 필요한 요구 사항은 사전 구성 선택, 실행 시 옵션 또는 해당 위험한 동작을 피하는 간단한 조치로 충족될 수 있습니다. 확인은 특정 사용자 인터페이스나 정상 처리의 중단을 의미하지 않으며, 사용자가 이미 해당 선택을 했다면 정상 처리가 진행될 수 있습니다.

	**2.3 중재자들**

	  HTTP는 연결 체인을 통해 중개자를 사용하여 요청을 충족시키는 기능을 제공합니다. HTTP 중개자에는 **프록시(proxy)**, **게이트웨이(gateway)** 및 **터널(tunnel)**의 세 가지 일반적인 형태가 있습니다. 경우에 따라 단일 중개자가 각 요청의 성격에 따라 원 서버, 프록시, 게이트웨이 또는 터널로 작동할 수 있습니다.
         ->       ->      ->      ->
	 UA ===== A ===== B ===== C ===== O
	      <-       <-      <-      <-
	      
	 위의 도표는 유저 에이전트와 원 서버 사이에 A, B, C라는 세 개의 중개자를 보여줍니다. 전체 체인을 통과하는 요청 또는 응답 메시지는 네 개의 별개의 연결을 통과합니다. 일부 HTTP 통신 옵션은 가장 가까운 터널이 아닌 이웃과의 연결에만 적용되거나 체인의 끝점에만 적용되거나 체인 전체의 모든 연결에 적용될 수 있습니다. 그림은 선형적이지만 각 참가자는 여러 개의 동시 통신에 참여할 수 있습니다. 예를 들어, B는 A 외에도 다른 클라이언트로부터 요청을 받거나 C 이외의 서버로 요청을 전달하면서 A의 요청을 처리하는 동시에 여러 개의 통신을 수행할 수 있습니다. 마찬가지로 나중의 요청은 로드 밸런싱을 위한 동적 구성에 따라 다른 연결 경로를 통해 전송될 수 있습니다.

	 [page 10] **"Upstream"** 과 **"downstream"** 이라는 용어는 메시지의 흐름과 관련하여 방향성 요구사항을 설명하는 데 사용됩니다. 모든 메시지는 "upstream"에서 "downstream"으로 흐릅니다. "Inbound"와 "outbound"라는 용어는 요청 경로와 관련하여 방향성 요구사항을 설명하는 데 사용됩니다. "Inbound"는 원 서버 쪽으로의 방향을 의미하며, 메시지가 처리를 위해 서버 쪽으로 이동하는 것을 나타냅니다. 반면에 "outbound"는 유저 에이전트 쪽으로의 방향을 의미하며, 메시지가 유저 에이전트 쪽으로 이동하여 소비되거나 표시되는 것을 나타냅니다.

	 "**프록시(proxy)**"는 주로 로컬 설정 규칙을 경유하여, 클라이언트에 의해 선택되는 메시지 전달 에이전트로 일부 유형의 절대 URI를 요청 받고 HTTP 인터페이스를 통해 해당 요청을 만족시키기 위해 번역을 시도합니다. 일부 번역은 최소한으로 이루어지며, "http" URI에 대한 프록시 요청과 같은 경우입니다. 반면에 다른 요청은 완전히 다른 응용 계층 프로토콜로의 번역이 필요할 수도 있습니다. 프록시는 종종 보안, 주석 서비스 또는 공유 캐싱을 위해 조직의 HTTP 요청을 공통 중개자를 통해 그룹화하는 데 사용됩니다. 일부 프록시는 전달되는 동안 선택된 메시지나 페이로드에 변형을 적용하는 것이 설명된 섹션 5.7.2에서 설명된 대로 설계될 수 있습니다.
	 
	 ![[local_configuration_rule.png]]

	 "**게이트웨이(gateway)**" (또는 "리버스 프록시")는 외부 연결("outbound")의 출발지 서버 역할을 하는 중개자로, 받은 요청을 번역하여 내부로 전달합니다. 게이트웨이는 종종 레거시 시스템이나 신뢰할 수 없는 정보 서비스를 캡슐화하거나, "가속기" 캐싱을 통해 서버 성능을 향상시키는 데 사용되며, HTTP 서비스를 여러 기기에 분할하거나 부하 분산을 가능하게 합니다.

	 모든 원본 서버에 적용되는 HTTP 요구사항은 게이트웨이의 외부 통신에도 적용됩니다. 게이트웨이는 원하는 프로토콜을 사용하여 인바운드 서버와 통신하며, 이는 이 명세의 범위를 벗어나는 HTTP에 대한 사적인 확장을 포함할 수 있습니다. 그러나 HTTP-to-HTTP 게이트웨이가 타사 HTTP 서버와 상호 운용하려는 경우에는 게이트웨이의 인바운드 연결에 대한 사용자 에이전트 요구사항을 준수하는 것이 좋습니다.

	 "**터널(tunnel)**"은 메시지를 변경하지 않으면서 두 연결 사이에서 블라인드 중계 역할을 수행합니다. 터널은 일단 활성화되면 HTTP 통신의 일부로 간주되지는 않지만, 그 자체는 HTTP 요청에 의해 시작될 수 있습니다. 터널은 양측의 연속적인 통신이 끝날 때 종료됩니다. 터널은 공유 방화벽 프록시를 통해 기밀 통신을 설정하기 위해 전송 계층 보안(TLS, [RFC5246])을 사용할 때와 같이 중개자를 통해 가상 연결을 확장하는 데 사용됩니다.

	 [page 11] 앞서 언급한 중개자에 대한 분류는 HTTP 통신의 참여자로서 작동하는 중개자만을 고려합니다. 그러나 메시지 발송자의 지식이나 허락 없이 HTTP 트래픽을 필터링하거나 리디렉션하는 등 네트워크 프로토콜 스택의 하위 계층에서 작동하는 중개자도 존재합니다. 이러한 네트워크 중개자는 프로토콜 수준에서 중간자 공격과 구별할 수 없으며, 종종 HTTP 의미론을 잘못 위반하여 보안 결함이나 상호 운용성 문제를 야기할 수 있습니다.

	 예를 들어, "interception proxy" [RFC3040] (일반적으로 "transparent proxy" [RFC1919] 또는 "captive portal"로도 알려짐)는 클라이언트에 의해 선택되지 않기 때문에 HTTP 프록시와는 다릅니다. 대신, 인터셉션 프록시는 나가는 TCP 포트 80 패킷(가끔 다른 일반적인 포트 트래픽도)을 필터링하거나 리디렉션합니다. 인터셉션 프록시는 일반적으로 공공 네트워크 접근 지점에서 찾을 수 있으며, 비로컬 인터넷 서비스 사용 전에 계정 구독을 강제하는 수단으로 사용되거나, 기업 방화벽에서 네트워크 사용 정책을 강제하는 용도로 사용됩니다.
	  
	 HTTP는 무상태 프로토콜로 정의되어 있으며, 그것은 각각의 요청 메시지가 독립적으로 이해될 수 있다는 의미입니다. 많은 구현이 프록시된 연결을 재사용하거나 여러 서버에 동적으로 요청을 로드 밸런싱하기 위해 HTTP의 상태 없는 디자인에 의존합니다. 따라서 서버는 연결이 보안되고 특정한 에이전트에게 속한 것인 경우를 제외하고는 동일한 연결에서 온 두 개의 요청이 동일한 사용자 에이전트에 의한 것으로 가정해서는 안 됩니다(**"MUST NOT"**). 비표준 HTTP 확장 (예: [RFC4559]) 중 일부는 이 요구사항을 위반하여 보안 및 상호 운용성 문제를 야기하는 것으로 알려져 있습니다.

	**2.4 캐시**

	 "캐시(cache)"는 이전 응답 메시지의 로컬 저장소와 해당 메시지의 저장, 검색 및 삭제를 제어하는 하위 시스템입니다. 캐시는 캐시 가능한 응답을 저장하여 이후 동등한 요청에 대한 응답 시간과 네트워크 대역폭 소비를 줄입니다. 클라이언트나 서버는 캐시를 사용할 수 있으나, 서버가 터널로 동작하는 동안에는 캐시를 사용할 수 없습니다.

	 [page 12] 캐시의 효과는 체인 상에 있는 참여자 중 하나가 해당 요청에 적용 가능한 캐시된 응답을 가지고 있을 경우, 요청/응답 체인이 단축된다는 것입니다. 다음은 UA 또는 A에 의해 캐시되지 않은 요청에 대해 B가 O(를 통해 C를 거쳐)의 이전 응답에 대한 캐시된 복사본을 가지고 있는 경우의 결과적인 체인을 보여줍니다.

      ---->          ---->	
	 UA =========== A =========== B - - - - - - C - - - - - - 
	 		  <--           <--

	 응답은 캐시가 해당 응답 메시지의 복사본을 저장하여 이후 요청에 대한 응답으로 사용할 수 있는 경우 "캐시 가능(cacheable)"하다고 할 수 있습니다. 응답이 캐시 가능하더라도 클라이언트나 원 서버에서 해당 캐시된 응답을 특정 요청에 사용할 때 추가적인 제약 사항이 있을 수 있습니다. 캐시 동작 및 캐시 가능한 응답에 대한 HTTP 요구사항은 [RFC7234]의 섹션 2에서 정의되어 있습니다.

	 세계적으로와 대규모 조직 내에서 다양한 아키텍처와 캐시 구성이 웹 전반에 걸쳐 배치되어 있습니다. 이에는 대양간 대역폭을 절약하기 위한 국가적인 프록시 캐시의 계층 구조, 캐시 항목을 브로드캐스트하거나 멀티캐스트하는 협업 시스템, 오프라인이나 높은 지연 환경에서 사용하기 위한 미리 가져온 캐시 항목의 아카이브 등이 포함됩니다.

	**2.5 표준 및 에러 처리**

	 이 사양은 HTTP 통신의 참여자 역할에 따른 준수 기준을 대상으로 합니다. 따라서 요구 사항에 의해 제한되는 동작에 따라 발신자, 수신자, 클라이언트, 서버, 사용자 에이전트, 중개자, 출처 서버, 프록시, 게이트웨이 또는 캐시에 HTTP 요구 사항이 부여됩니다. 단일 통신의 범위를 벗어나는 경우 구현, 리소스 소유자 및 프로토콜 요소 등에 추가 (사회적) 요구 사항이 부여됩니다.

	 "generate"라는 동사는 요구 사항이 프로토콜 요소를 생성하는 것과 단순히 수신한 요소를 하류로 전달하는 것을 구분하는 경우 "send" 대신 사용됩니다.

	 HTTP에 참여하는 역할과 관련된 모든 요구 사항을 준수하는 경우 구현은 준수되는 것으로 간주됩니다.
	
	 준수는 프로토콜 요소의 구문 및 의미를 포함합니다. 발신자는 자신이 거짓으로 알고 있는 의미를 전달하는 프로토콜 요소를 생성해서는 안 됩니다. 발신자는 해당 ABNF 규칙에 의해 정의된 문법과 일치하지 않는 프로토콜 요소를 생성해서는 안 됩니다. 주어진 메시지 내에서 발신자는 다른 역할의 참여자만이 생성할 수 있는 프로토콜 요소나 구문 대안을 생성해서는 안 됩니다 (즉, 발신자가 해당 메시지에 대해 가지지 않은 역할).

	 수신된 프로토콜 요소가 구문 분석될 때, 수신자는 수신자의 역할에 적용 가능하고 해당 ABNF 규칙에 정의된 문법과 일치하는 합리적인 길이의 모든 값을 구문 분석할 수 있어야 합니다. 그러나 수신된 프로토콜 요소 중 일부는 구문 분석되지 않을 수도 있습니다. 예를 들어, 메시지를 전달하는 중개자는 헤더 필드를 일반적인 필드 이름과 필드 값 구성 요소로 구문 분석할 수 있지만, 필드 값 내에서 추가로 구문 분석하지 않고 헤더 필드를 전달할 수도 있습니다.

	 [page 13] HTTP는 많은 프로토콜 요소에 대해 특정 길이 제한을 갖고 있지 않습니다. 이는 적절한 길이가 배치 환경과 구현의 목적에 따라 크게 달라질 수 있기 때문입니다. 따라서 발신자와 수신자 간의 상호 운용성은 각 프로토콜 요소에 대해 어떤 길이가 합리적인지에 대한 공유된 기대에 따라 달려있습니다. 게다가, 몇 가지 프로토콜 요소에 대해 일반적으로 합리적인 길이로 인식되는 것은 HTTP 사용의 지난 20년 동안 변경되어왔으며, 미래에도 계속 변화할 것으로 예상됩니다.

	 최소한으로, 수신자는 다른 메시지에서 동일한 프로토콜 요소에 대해 생성하는 값과 동일한 길이 이상의 프로토콜 요소 길이를 구문 분석하고 처리할 수 있어야 합니다(**"MUST"**). 예를 들어, 자체 자원에 대해 매우 긴 URI 참조를 발행하는 출처 서버는 해당 참조를 요청 대상으로 수신받을 때 구문 분석하고 처리할 수 있어야 합니다.

	 수신자는 수신한 프로토콜 요소를 이 사양에 의해 정의된 의미에 따라 해석해야 합니다(**"MUST"**). 이 사양의 확장을 포함하여 의미에 의해 암시되는 것을 발신자가 잘못 구현한다고 판단하지 않은 한 (경험 또는 구성을 통해), 예외가 아닌 경우 프로토콜 요소를 사용자 정의해야 합니다. 예를 들어, 특정 콘텐츠 인코딩을 수신할 경우 실패하는 특정 구현 버전을 나타내는 User-Agent 헤더 필드 검사를 통해 Accept-Encoding 헤더 필드의 내용을 무시할 수 있습니다.
	
	 특별히 언급되지 않은 경우, 수신자는 잘못된 구조에서 사용 가능한 프로토콜 요소를 복구하려고 시도할 수 있습니다. HTTP는 프로토콜의 다양한 응용에 따라 다른 오류 처리 전략이 필요하기 때문에, 보안에 직접적인 영향을 미치는 경우를 제외하고는 특정 오류 처리 메커니즘을 정의하지 않습니다. 예를 들어, 웹 브라우저는 ABNF에 따라 구문 분석되지 않는 경우 Location 헤더 필드에서 투명하게 복구하려 할 수 있으나, 시스템 제어 클라이언트는 오류 복구의 어떤 형태도 위험하다고 간주할 수 있습니다.
	
	**2.6 프로토콜 버전 관리**
	
	 HTTP는 프로토콜의 버전을 나타내기 위해 'major.minor' 번호 스킴을 사용합니다. 이 명세서는 버전 "1.1"을 정의합니다. 프로토콜 버전은 해당 버전의 HTTP 명세서에 기술된 요구 사항 집합에 대한 발신자의 준수를 나타냅니다.

	 HTTP 메시지의 버전은 메시지의 첫 번째 줄에 있는 HTTP-version 필드로 나타냅니다. HTTP-version은 대소문자를 구분합니다.
	
	 HTTP-version  = HTTP-name "/" DIGIT "." DIGIT
	 HTTP-name     = %x48.54.54.50 ; "HTTP", 대소문자를 구분합니다.

	 HTTP 버전 번호는 "." (점 또는 소수점)으로 구분된 두 개의 십진 숫자로 구성됩니다. 첫 번째 숫자("주 버전")는 HTTP 메시징 구문을 나타내며, 두 번째 숫자("부 버전")는 발신자가 준수하고 이해할 수 있는 주 버전 내에서의 가장 높은 부 버전을 나타냅니다. 부 버전은 발신자의 통신 능력을 알리며, 발신자가 프로토콜의 하위 호환성 부분 집합만 사용하는 경우에도 더 발전된 기능을 응답(서버에서)이나 미래의 요청(클라이언트에서)에서 사용할 수 있다는 것을 수신자에게 알려줍니다.

	 HTTP/1.1 메시지가 HTTP/1.0 수신자 [RFC1945] 또는 버전이 알려지지 않은 수신자에게 전송될 때, HTTP/1.1 메시지는 최신 기능을 무시하면 유효한 HTTP/1.0 메시지로 해석될 수 있도록 구성됩니다. 이 명세서는 수신자 버전에 대한 일부 새로운 기능의 요구 사항을 설정하여 준수하는 발신자가 HTTP/1.1을 지원하는 수신자를 확인하기 전까지 호환 가능한 기능만 사용하도록 합니다. 이는 구성 또는 메시지 수신을 통해 수신자가 HTTP/1.1을 지원하는 것을 확인하기 전까지입니다.

	 같은 주 버전의 부 버전 간에 헤더 필드의 해석은 변경되지 않지만, 해당 필드가 없을 때 수신자의 기본 동작은 변경될 수 있습니다. 특별히 명시되지 않은 경우, HTTP/1.1에서 정의된 헤더 필드는 모든 HTTP/1.x 버전에 대해 정의됩니다. 특히, Host 및 Connection 헤더 필드는 HTTP/1.1의 준수 여부와 관계없이 모든 HTTP/1.x 구현에서 구현되어야 합니다.

	 새로운 헤더 필드는 정의된 의미가 인식하지 못하는 수신자에게 안전하게 무시될 수 있도록 허용되는 경우에는 프로토콜 버전을 변경하지 않고도 도입될 수 있습니다. 헤더 필드의 확장성은 섹션 3.2.1에서 논의됩니다.

	 HTTP 메시지를 처리하는 중개자(즉, 터널로 동작하지 않는 모든 중개자)은 전달된 메시지에서 자체적인 HTTP-version을 보내야 합니다("**MUST**"). 다시 말해, 중개자는 메시지의 첫 번째 줄을 맹목적으로 전달하는 것이 아니라, 해당 중개자가 수신 및 송신 메시지에 대해 준수하는 버전과 일치하는지 확인한 후에 메시지를 전달해야 합니다. HTTP-version을 재작성하지 않고 HTTP 메시지를 전달하는 것은, 하위 수신자가 메시지 전송자의 버전을 사용하여 이후 통신에 안전하게 사용할 수 있는 기능을 결정할 때 통신 오류가 발생할 수 있습니다.

	 [page 15] 클라이언트는 알고 있는 경우, 서버가 지원하는 가장 높은 버전보다 높지 않은 주 버전에 해당하고 클라이언트가 준수하는 가장 높은 버전과 동일한 요청 버전을 보내는 것이 좋습니다(**"SHOULD"**). 클라이언트는 자신이 준수하지 않는 버전을 보내서는 안 됩니다(**"MUST NOT"**).

	 클라이언트는 서버가 HTTP 사양을 잘못 구현하고 있음을 알고 있는 경우에만 정상적인 요청을 적어도 한 번 시도하고, 응답 상태 코드나 헤더 필드 (예: Server)에서 서버가 더 높은 요청 버전을 잘못 처리한다고 판단한 후에만 더 낮은 요청 버전을 보낼 수 있습니다(**"MAY"**).

	 서버는 요청으로 받은 주 버전보다 작거나 같은 주 버전을 준수하는 가장 높은 버전과 동일한 응답 버전을 보내는 것이 좋습니다(**"SHOULD"**). 서버는 자신이 준수하지 않는 버전을 보내서는 안 됩니다. 서버는 특정한 이유로 클라이언트의 주 프로토콜 버전의 서비스를 거부하고자 하는 경우 505 (HTTP Version Not Supported) 응답을 보낼 수 있습니다.

	 서버는 클라이언트가 HTTP 사양을 잘못 구현하고 후속 버전의 응답을 올바르게 처리할 수 없다고 의심되는 경우에만 요청에 HTTP/1.0 응답을 보낼 수 있습니다(**"MAY"**). 이는 클라이언트가 버전 번호를 올바르게 구문 분석하지 못하는 경우나 중개자가 프로토콜의 주 버전에 부합하지 않더라도 HTTP-version을 무조건 전달하는 경우 등이 있습니다. 이러한 프로토콜 다운그레이드는 특정 클라이언트 속성에 의해 트리거되지 않는 한 수행해서는 안 되며(**"SHOULD NOT"**, 예를 들어 요청 헤더 필드 (예: User-Agent) 중 하나 이상이 오류가 있는 클라이언트가 보낸 값과 일치하는 경우에만 수행되어야 합니다.

	 HTTP의 버전 설계의 의도는 호환되지 않는 메시지 구문이 도입될 때만 주 번호를 증가시키고, 프로토콜에 변경 사항이 추가되어 메시지 의미를 추가하거나 발신자의 추가 기능을 암시하는 경우에만 부 번호를 증가시키는 것입니다. 그러나 [RFC2068]과 [RFC2616] 사이에 도입된 변경 사항으로 인해 부 번호가 증가되지 않았으며, 이 개정판은 프로토콜에 어떠한 변경 사항도 포함하지 않도록 특별히 조치되었습니다.

	 수신자가 구현하는 주 번호와 일치하지만 수신자가 구현하는 부 번호보다 더 높은 부 번호를 가진 HTTP 메시지를 수신한 경우, 수신자는 수신자가 준수하는 해당 주 번호 내에서 가장 높은 부 번호로 메시지를 처리해야 합니다. 수신자는 아직 해당 높은 버전을 지원하지 않은 수신자에게 보내지만 충분히 하위 호환성이 있는 메시지를 안전하게 처리할 수 있는 것으로 가정할 수 있습니다. 이는 동일한 주 번호의 모든 구현에서 처리될 수 있다고 할 수 있습니다.

	**2.7. 통합 자원 식별자**

	 [page 16] 통합 자원 식별자(Uniform Resource Identifiers, URIs) [RFC3986]는 HTTP에서 자원을 식별하는 수단으로 사용됩니다([RFC7231]의 2장). URI 참조는 요청을 대상으로 하거나 리디렉션을 나타내고 관계를 정의하는 데 사용됩니다.
	
	 "URI-reference(URI 참조)", "absolute-URI(절대 URI)", "relative-part(상대 경로)", "scheme", "authority(인증)", "port(포트)", "host(호스트)", "path-abempty(빈 경로를 포함하는 경로)", "segment(세그먼트)", "query(쿼리)", 그리고 "fragment"의 정의는 URI 일반 구문에서 채택되었습니다. 비어 있지 않은 경로 구성 요소를 포함할 수 있는 프로토콜 요소에 대해 "절대 경로" 규칙이 정의되었습니다. (이 규칙은 RFC 3986의 path-abempty 규칙과 약간 다르며, 참조에 빈 경로를 사용할 수 있게 허용하는 path-absolute 규칙과 "//"로 시작하는 경로를 허용하지 않는 path-absolute 규칙과 다릅니다.) 상대 URI를 포함할 수 있지만 프래그먼트 구성 요소를 포함할 수 없는 프로토콜 요소에 대해 "부분 URI" 규칙이 정의되었습니다.
	
     URI-reference = <URI-reference, see [[RFC3986], Section 4.1](https://datatracker.ietf.org/doc/html/rfc3986#section-4.1)>
     absolute-URI  = <absolute-URI, see [[RFC3986], Section 4.3](https://datatracker.ietf.org/doc/html/rfc3986#section-4.3)>
     relative-part = <relative-part, see [[RFC3986], Section 4.2](https://datatracker.ietf.org/doc/html/rfc3986#section-4.2)>
     scheme        = <scheme, see [[RFC3986], Section 3.1](https://datatracker.ietf.org/doc/html/rfc3986#section-3.1)>
     authority     = <authority, see [[RFC3986], Section 3.2](https://datatracker.ietf.org/doc/html/rfc3986#section-3.2)>
     uri-host      = <host, see [[RFC3986], Section 3.2.2](https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.2)>
     port          = <port, see [[RFC3986], Section 3.2.3](https://datatracker.ietf.org/doc/html/rfc3986#section-3.2.3)>
     path-abempty  = <path-abempty, see [[RFC3986], Section 3.3](https://datatracker.ietf.org/doc/html/rfc3986#section-3.3)>
     segment       = <segment, see [[RFC3986], Section 3.3](https://datatracker.ietf.org/doc/html/rfc3986#section-3.3)>
     query         = <query, see [[RFC3986], Section 3.4](https://datatracker.ietf.org/doc/html/rfc3986#section-3.4)>
     fragment      = <fragment, see [[RFC3986], Section 3.5](https://datatracker.ietf.org/doc/html/rfc3986#section-3.5)>

     absolute-path = 1*( "/" segment )
     partial-URI   = relative-part [ "?" query ]

	 HTTP에서 URI 참조를 허용하는 각 프로토콜 요소는 해당 ABNF 표기법에서 요소가 어떤 형태의 참조를 허용하는지를 나타냅니다. 참조 형식(URI-reference), 절대 URI 형식 (absolute-URI), 경로와 선택적인 쿼리 구성 요소만 허용하는지 또는 이러한 요소들의 조합 중 어떤 것을 허용하는지를 나타냅니다. 그렇지 않은 한, URI 참조는 효과적인 요청 URI (Section 5.5)를 기준으로 상대적으로 구문 분석됩니다.

	**2.7 (1) http URI 스킴(scheme)**
	
	 [page 17] **"http" URI 스킴**은 주어진 포트에서 TCP ([RFC0793]) 연결을 수신 대기하는 잠재적인 HTTP 오리진 서버와의 연관성에 따라 식별자를 생성하기 위해 여기에 정의됩니다.

	 http-URI = "http:" "//" authority path-abempty [ "?" query ]
                [ "#" fragment ]

	 "HTTP" URI에 대한 오리진 서버는 authority 구성 요소에 의해 식별됩니다. 이는 호스트 식별자와 선택적인 TCP 포트([RFC3986], 섹션 3.2.2)를 포함합니다. 계층적인 경로 구성 요소와 선택적인 쿼리 구성 요소는 해당 오리진 서버의 네임스페이스 내에서 잠재적인 대상 리소스를 식별하는 데 사용됩니다. 선택적인 프래그먼트 구성 요소는 URI 스킴과 독립적인 보조 리소스의 간접적인 식별을 허용합니다. 이는 [RFC3986]의 섹션 3.5에서 정의되어 있습니다.

	 송신자는 빈 호스트 식별자를 가진 "http" URI를 생성해서는 안 됩니다. 이와 같은 URI 참조를 처리하는 수신자는 이를 잘못된 것으로 판단하여 거부해야 합니다("**MUST NOT**").

	 만약 호스트 식별자가 IP 주소로 제공된다면, 해당 IP 주소에서 지정된 TCP 포트에 대한 수신자(있을 경우)가 원 서버입니다. 호스트가 등록된 이름인 경우, 등록된 이름은 DNS와 같은 이름 해결 서비스와 함께 사용하기 위한 간접 식별자입니다. 만약 포트 하위 구성요소가 비어 있거나 주어지지 않은 경우, **TCP 포트 80** (WWW 서비스를 위한 예약된 포트)가 기본값으로 사용됩니다.

	 주어진 권한 구성 요소를 가진 URI의 존재는 항상 해당 호스트와 포트에서 연결을 수신하는 HTTP 서버가 있는 것을 의미하지는 않습니다. 누구나 URI를 생성할 수 있습니다. 권한 구성 요소가 결정하는 것은 식별된 리소스를 대상으로 권위있게 응답할 권한을 가진 사람이 누구인지입니다. 등록된 이름과 IP 주소의 위임성은 HTTP 서버의 존재 유무와 상관없이 지정된 호스트와 포트에 대한 통제를 기반으로 한 연합된 네임스페이스를 생성합니다. 권한을 설정하는 데 관련된 보안 고려 사항에 대해서는 섹션 9.1을 참조하십시오.

	 "http" URI가 해당 리소스에 액세스할 필요가 있는 문맥에서 사용될 때, 클라이언트는 호스트를 IP 주소로 해석하고, 지정된 포트의 해당 주소에 TCP 연결을 설정하고, HTTP 요청 메시지 (섹션 3)를 서버로 보내는 것으로 액세스를 시도할 수 있습니다("**MAY**"). 만약 서버가 그 요청에 대해 [RFC7231]의 섹션 6에 설명된대로 중간 응답이 아닌 HTTP 응답 메시지로 응답한다면, 그 응답은 클라이언트의 요청에 대한 권위있는 답변으로 간주됩니다.

	  [page 18] HTTP는 전송 프로토콜과 독립적이지만, "http" 스킴은 TCP 기반 서비스에 특화되어 있습니다. 이는 이름 위임 프로세스가 권한을 설정하기 위해 TCP에 의존하기 때문입니다. 다른 기반 연결 프로토콜을 사용하는 HTTP 서비스는 다른 URI 스킴을 사용하여 식별될 것으로 예상됩니다. 마찬가지로 "https" 스킴은 끝간 보안 연결이 필요한 리소스에 사용됩니다. 다른 프로토콜도 "http"로 식별된 리소스에 액세스를 제공하는 데 사용될 수 있지만, TCP에 대한 권한 인터페이스만이 특정되어 있습니다.
  
	 URI의 일반 구문인 authority에는 userinfo 하위 구성 요소도 포함되어 있습니다. userinfo는 URI에 사용자 인증 정보를 포함하는 데 사용되며 ([RFC3986], 섹션 3.2.1), 이는 사용자 식별자 또는 암호를 노출시킬 수 있는 경우가 있습니다. 일부 구현은 userinfo 구성 요소를 내부 인증 정보의 구성을 위해 사용할 수 있습니다. 이는 명령 호출 옵션, 구성 파일 또는 즐겨찾기 목록 내에서 사용될 수 있습니다. 그러나 이러한 사용은 사용자 식별자 또는 암호를 노출시킬 수 있습니다. "http" URI 참조가 요청 대상이나 헤더 필드 값으로 메시지 내에서 생성될 때, 보낸 사람은 userinfo 하위 구성 요소와 "@" 구분 기호를 생성해서는 안 됩니다. 신뢰할 수 없는 출처에서 수신한 "http" URI 참조를 사용하기 전에, 수신자는 userinfo를 구문 분석하고 존재 여부를 오류로 처리해야 합니다. 이는 피싱 공격을 위해 권한을 은닉하기 위해 사용되는 경우일 가능성이 있습니다.

	**2.7 (2) https URI 스킴(scheme)**

	 "https" URI scheme은 TLS-보안 연결을 위해 지정된 TCP 포트에서 HTTP 원 서버를 수신 대기 중인 분산 네임스페이스와의 연관성을 기준으로 식별자를 생성하기 위해 정의됩니다 ([RFC5246]).

	 위에서 "http" scheme에 대해 나열된 요구 사항은 "https" scheme에 대해서도 동일하게 적용됩니다. 다만, 포트 하위 구성 요소가 비어 있거나 제공되지 않는 경우 **TCP 포트 443**이 기본값으로 사용되며, 사용자 에이전트는 첫 번째 HTTP 요청을 보내기 전에 강력한 암호화를 통해 원 서버와의 연결이 암호화되어 있는지 보장해야 합니다.
	
	 https-URI = "https:" "//" authority path-abempty [ "?" query ]
                 [ "#" fragment ]

	 "https" URI scheme은 권한을 설정하기 위해 TLS와 TCP 모두에 의존한다는 점에 주목해야 합니다. "https" scheme을 통해 제공되는 리소스는 리소스 식별자가 동일한 권한(동일한 호스트가 동일한 TCP 포트를 수신 대기 중인 경우)을 나타내더라도 "http" scheme과 공유된 식별자가 없습니다. 이들은 서로 다른 네임스페이스로 간주되며, 서로 다른 원 서버로 간주됩니다. 그러나 "Cookie protocol" [RFC6265]과 같이 전체 호스트 도메인에 적용되는 HTTP 확장 프로토콜은 한 서비스에서 설정한 정보가 해당 호스트 도메인의 다른 서비스와의 통신에 영향을 줄 수 있습니다.

	 "https" 식별된 리소스에 대한 권한 있는 액세스 과정은 [RFC2818]에 정의되어 있습니다.

	**2.7 (3) http, 그리고 https URI 정규화와 비교

	 [page 19] "http" 및 "https" 스키마는 URI 일반 구문을 준수하므로 이러한 URI는 각 스키마에 대해 위에서 설명한 기본값을 사용하여 정규화되고 비교됩니다. 이를 위해 [RFC3986]의 6장에 정의된 알고리즘을 사용합니다.

	 만약 포트가 해당 스킴의 기본 포트와 동일한 경우, 일반적으로 포트 하위 구성요소를 생략하는 것이 정규 형식입니다. OPTIONS 요청의 요청 대상으로서 절대 형식으로 사용되지 않을 때, 빈 경로 구성요소는 "/"로 절대 경로와 동등하므로, 일반적으로 경로를 "/"로 제공하는 것이 정규 형식입니다. 스킴과 호스트는 대소문자를 구별하지 않으며, 일반적으로 소문자로 제공됩니다. 다른 모든 구성요소는 대소문자를 구별하여 비교됩니다. "예약"된 집합에 속하지 않는 문자는 해당하는 퍼센트 인코딩된 옥텟과 동일합니다. 즉, 일반적으로 인코딩하지 않는 것이 정규 형식입니다 ([RFC3986]의 2.1절과 2.2절을 참조하십시오).
	 
	 예를 들어, 다음 세 개의 URI는 동등합니다:
	 
	 [http://example.com:80/~smith/home.html](http://example.com/~smith/home.html)  [http://EXAMPLE.com/%7Esmith/home.html](http://example.com/~smith/home.html)  [http://EXAMPLE.com:/%7esmith/home.html](http://example.com/~smith/home.html)

3) **Message Format**

	- **Introduction**
	 모든 HTTP/1.1 메시지는 시작 줄(start-line)로 시작하며, 이어서 인터넷 메시지 형식 [RFC5322]과 유사한 형식의 옥텟 시퀀스가 따라옵니다. 이는 0개 혹은 더 많은 헤더 필드(헤더 또는 헤더 섹션으로 통칭됨)로 구성되며, 헤더 섹션의 끝을 나타내는 빈 줄이 있고, 선택적인 메시지 본문이 옵니다.

	 HTTP-메시지는 다음과 같은 구조를 갖습니다:

	 HTTP-메시지 = 시작-줄               
					 (헤더-필드 CRLF)              
					 CRLF               
					 [메시지-본문]

	 (상세) 여기서:

	 - `시작-줄`은 메시지의 첫 줄로 구성되며, 요청 메시지인 경우 요청 라인(request line)이고, 응답 메시지인 경우 상태 라인(status line)입니다.
	 - `헤더-필드`는 헤더 섹션의 각 필드를 나타내며, 이름과 값으로 구성됩니다.
	 - `CRLF`는 캐리지 리턴(CR)과 개행 문자(LF)를 나타냅니다.
	 - `메시지-본문`은 선택적으로 포함될 수 있는 메시지의 실제 내용입니다.
	 -----------------------
	 [예시]
	 GET /example HTTP/1.1      **(start-line)**
	 Host: www.example.com      **(header field)**
	 User-Agent: Mozilla/5.0 
	 Accept-Language: en-US 
	 Content-Length: 0
                                **(CRLF)**
	 [Message-body]             **(Message-body)**
	 ------------------------

	 HTTP 메시지를 파싱하는 일반적인 절차는 다음과 같습니다:
	
	 1. `start-line`을 구조체에 읽어들입니다. `start-line`에는 HTTP 메소드, 요청 대상 (URI), 그리고 HTTP 버전과 같은 정보가 포함되어 있습니다.
	 2. 각각의 `header field`를 읽어들여 필드 이름에 따라 해시 테이블 또는 딕셔너리와 같은 데이터 구조에 저장합니다. 각 header field는 콜론으로 구분된 필드 이름과 필드 값으로 구성됩니다.
	 3. 빈 줄이 나올 때까지 header field를 계속해서 읽습니다.
	
	 헤더 필드를 모두 읽은 후, 파싱된 데이터를 사용하여 메시지 본문이 예상되는지 여부를 판단합니다. 메시지 본문이 있는 경우, 메시지 본문 길이와 같은 개수의 옥텟이 읽힐 때까지 또는 연결이 닫힐 때까지 스트림으로 메시지 본문을 읽습니다.
	 
	 [page 20] 수신자는 반드시 HTTP 메시지를 US-ASCII [USASCII]의 상위 집합으로 인코딩된 옥텟의 시퀀스로 파싱해야 합니다. 특정 인코딩을 고려하지 않고 유니코드 문자의 스트림으로 HTTP 메시지를 파싱하는 것은 보안 취약점을 초래할 수 있습니다. 이는 문자열 처리 라이브러리가 옥텟 LF (%x0A)를 포함하는 잘못된 다중바이트 문자 시퀀스를 처리하는 방식이 다양하기 때문입니다. 문자열 기반의 파서는 메시지에서 해당 요소가 추출된 후, 개별 필드를 구분한 메시지 파싱 이후에 헤더 필드 값과 같은 프로토콜 요소 내에서 안전하게 사용할 수 있습니다.
	 
	 HTTP 메시지는 점진적인 처리나 하향으로의 전달을 위해 스트림으로 파싱될 수 있습니다. 그러나 수신자는 부분 메시지의 점진적인 전달에 의존할 수 없습니다. 왜냐하면 일부 구현은 네트워크 효율성, 보안 검사 또는 페이로드 변환을 위해 메시지 전달을 버퍼링하거나 지연시킬 수 있기 때문입니다.

	 송신자는 시작 줄과 첫 번째 헤더 필드 사이에 공백을 보내서는 안 됩니다(**"MUST NOT"**). 시작 줄과 첫 번째 헤더 필드 사이에 공백을 수신하는 수신자는 메시지를 잘못된 것으로 거부하거나 각 공백으로 시작하는 줄을 추가 처리하지 않고 사용해야 합니다(즉, 헤더 필드가 제대로 형식화되거나 헤더 섹션이 종료될 때까지 해당 줄과 공백으로 시작하는 임의의 후속 줄을 무시해야 함).
	 
	 요청에서 이러한 공백이 존재하는 경우, 해당 필드를 무시하거나 그 후의 줄을 새로운 요청으로 처리하도록 서버를 속이려는 시도일 수 있습니다. 이는 요청 체인 내의 다른 구현이 동일한 메시지를 다르게 해석하는 경우 보안 취약점을 초래할 수 있습니다. 마찬가지로 응답에서 이러한 공백의 존재는 일부 클라이언트에서 무시되거나 다른 클라이언트에서 파싱을 중지시킬 수 있습니다.

	**3.1 Start Line**
	
	 HTTP 메시지는 클라이언트에서 서버로의 요청이나 서버에서 클라이언트로의 응답일 수 있습니다. 구문적으로, 이 두 유형의 메시지는 시작 라인만 다르며, 요청일 경우에는 request-line이고 응답일 경우에는 status-line입니다. 또한 메시지 본문의 길이를 결정하는 알고리즘도 다릅니다 (3.3절).

	 이론적으로 클라이언트는 요청을 수신하고 서버는 응답을 수신할 수 있으며, 이들은 서로 다른 시작 라인 형식으로 구분될 수 있습니다. 그러나 실제로는 서버는 요청만 예상하도록 구현되어 있으며 (응답은 알 수 없거나 잘못된 요청 방법으로 해석됨), 클라이언트는 응답만 예상하도록 구현됩니다.
	 
	 **start-line = request-line / status-line**

	**3.1 (1) Request Line**

	 [page 21] 요청 라인은 메소드 토큰으로 시작하며, 그 뒤에는 단일 공백(Space, SP), 요청 대상(request-target), 다시 단일 공백(Space, SP), 프로토콜 버전, 그리고 CRLF(Carriage Return Line Feed)이 따릅니다.
	 
	 - **request-line = method SP request-target SP HTTP-version CRLF**
	 
	 메소드 토큰은 대상 리소스에 대해 수행할 요청 메소드를 나타냅니다. 요청 메소드는 대소문자를 구분합니다.
	 
	 - **method     = token**

	 이 사양에서 정의된 요청 메소드는 [RFC7231]의 섹션 4에 찾을 수 있으며, HTTP 메소드 레지스트리와 새로운 메소드를 정의하는 데 대한 고려 사항에 대한 정보도 해당 섹션에 포함되어 있습니다.
	
	 요청 대상은 요청을 적용할 대상 리소스를 식별합니다. 이에 대한 정의는 섹션 5.3에 설명되 어 있습니다.
	 
	 수신자는 일반적으로 요청 라인을 구성 요소로 분할하기 위해 공백을 기준으로 분리합니다(섹션 3.5 참조). 각 구성 요소에는 공백이 허용되지 않기 때문입니다. 하지만, 일부 사용자 에이전트는 하이퍼텍스트 참조에서 발견된 공백을 올바르게 인코딩하거나 제외하지 못하여, 이러한 금지된 문자가 요청 대상으로 전송되는 경우가 있습니다.
	 
	 유효하지 않은 요청 라인을 수신한 경우, 수신자는 400 (잘못된 요청) 오류 또는 301 (영구적으로 이동함) 리디렉션 중 하나로 응답해야 합니다. 응답할 때는 요청 대상을 올바르게 인코딩해야 합니다. 수신자는 리디렉션 없이 요청을 자동으로 수정하고 처리하려고 시도해서는 안 됩니다. 왜냐하면, 유효하지 않은 요청 라인은 요청 체인을 통해 보안 필터를 우회하기 위해 고의적으로 조작된 것일 수 있기 때문입니다.
	 
	 HTTP는 요청 라인의 길이에 미리 정의된 제한을 두지 않습니다(Section 2.5 참조). 서버가 구현한 어떤 메서드보다 긴 메서드를 받은 경우, 501 (구현되지 않음) 상태 코드로 응답해야 합니다. 서버가 구문 분석하려는 URI보다 긴 요청 대상을 받은 경우, 414 (URI가 너무 긺) 상태 코드로 응답해야 합니다 ([RFC7231의 섹션 6.5.12 참조]).
	 
	 실제로는 요청 라인 길이에 대한 다양한 임시 제한이 존재합니다. HTTP 송신자 및 수신자는 최소한 8000옥텟의 요청 라인 길이를 지원하는 것이 권장됩니다.

	**3.1 (2) Status Line**

	 [page 22] 응답 메시지의 첫 번째 줄은 상태줄(status-line)로 구성되며, 프로토콜 버전, 공백(SP), 상태 코드, 다른 공백, 상태 코드를 설명하는 비어 있을 수도 있는 텍스트 구문, 그리고 CRLF로 끝납니다.
	 
	 **- status-line = HTTP-version SP "status-code" SP "reason-phrase"                   CRLF**

	 **status-code** 요소는 서버가 클라이언트의 해당 요청을 이해하고 처리한 결과를 나타내는 3자리 정수 코드입니다. 응답 메시지의 나머지는 해당 상태 코드에 대해 정의된 의미에 따라 해석되어야 합니다. 상태 코드의 의미, 상태 코드의 클래스(첫 번째 숫자로 표시됨), 이 사양에서 정의된 상태 코드, 새로운 상태 코드를 정의하는 데 고려해야 할 사항 및 IANA 레지스트리에 대한 정보는 [RFC7231]의 섹션 6을 참조하십시오.

	 - **status code = 3DIGIT** 

	 reason-phrase 요소는 숫자 상태 코드와 관련된 텍스트 설명을 제공하는 유일한 목적으로 존재합니다. 이는 이전에 대화형 텍스트 클라이언트와 더 자주 사용되는 인터넷 응용 프로토콜을 고려하여 제공됩니다. 클라이언트는 reason-phrase 콘텐츠를 무시해야 합니다.

	  - reason-phrase = * (HTAB / SP / VCHAR / obs-text)

	**3.2 Header Fields
	   
	 각 헤더 필드는 대소문자를 구분하지 않는 필드 이름으로 시작하여 콜론 (":"), 선택적인 선행 공백, 필드 값 및 선택적인 후행 공백으로 구성됩니다.
	 ---------------------------------------------------------
	 header-field = field-name ":" OWS field-value OWS

	 field-name = token 
	 field-value = * (field-content / obs-fold) 
	 field-content = field-vchar [1_(SP / HTAB) field-vchar] 
	 field-vchar = VCHAR / obs-text

	  obs-fold = CRLF 1* (SP / HTAB) 
					; 구식 줄 접기 ; 
					섹션 3.2.4를 참조하세요.
	 ---------------------------------------------------------
	 field-name 토큰은 해당 필드 값이 해당 헤더 필드에서 정의된 의미를 가진다는 것을 나타냅니다. 예를 들어, Date 헤더 필드는 [RFC7231]의 7.1.1.2 섹션에서 해당 메시지에 대한 발생 시간 정보를 포함한다고 정의되어 있습니다.

	**3.2 (1) Field Extensibility**
 
	 [page 23] 헤더 필드는 완전히 확장 가능합니다. 새로운 필드 이름의 도입에는 제한이 없으며, 각각은 새로운 의미를 정의할 것으로 예상됩니다. 또한, 특정 메시지에서 사용되는 헤더 필드의 수에도 제한이 없습니다. 기존 필드는 이 사양의 각 부분과 이 문서 세트 외의 많은 다른 사양에서도 정의되어 있습니다.

	 새로운 헤더 필드는 수신자가 이해하는 경우 이전에 정의된 헤더 필드의 해석을 무효화하거나 개선할 수 있으며, 요청 평가에 사전 조건을 정의하거나 응답의 의미를 더욱 명확하게 할 수 있습니다.

	 프록시는 Connection 헤더 필드 (섹션 6.1)에 나열된 field-name이 아닌 인식되지 않은 헤더 필드를 전달해야 합니다. 프록시는 특별히 이러한 필드를 차단하거나 변형하기 위해 구성되어 있어야 합니다. 다른 수신자는 인식되지 않은 헤더 필드를 무시해야 합니다. 이러한 요구 사항은 HTTP의 기능을 배포된 중개 서버를 미리 업데이트하지 않고도 향상시킬 수 있도록 합니다.

	 모든 정의된 헤더 필드는 "Message Headers" 레지스트리에 IANA에 등록되어야 합니다. 이에 대한 자세한 내용은 [RFC7231]의 섹션 8.3을 참조하십시오.

	 프록시는 필드 이름이 연결 헤더 필드에 나열되어 있거나, 프록시가 해당 필드를 차단하거나 다른 방식으로 변환하도록 특별히 구성되지 않은 한 인식할 수 없는 헤더 필드를 전달해야 합니다. 다른 수신자는 인식할 수 없는 헤더 필드를 무시해야 합니다(**"SHOULD"**). 이러한 요구 사항을 통해 배포된 중개자를 사전에 업데이트할 필요 없이 HTTP의 기능을 향상시킬 수 있습니다.
	 
	 모든 정의된 헤더 필드는 "Message Headers" 레지스트리에 IANA에 등록되어야 합니다. 이에 대한 자세한 내용은 [RFC7231]의 섹션 8.3을 참조하십시오.

	**3.2 (2) Field Order**
	
	 서로 다른 필드 이름을 가진 헤더 필드의 순서는 중요하지 않습니다. 그러나 Host(요청)와 Date(응답)와 같은 제어 데이터를 포함하는 헤더 필드를 가능한 빨리 보내는 것이 좋은 방법입니다. 이렇게 함으로써 구현체는 메시지를 더 이상 처리하지 않아도 되는 시점을 가능한 빠르게 결정할 수 있습니다. 서버는 전체 요청 헤더 섹션이 수신될 때까지 대상 리소스에 요청을 적용해서는 안 됩니다("**MUST NOT**"). 이는 나중에 오는 헤더 필드에 조건절, 인증 자격 증명 또는 의도적으로 잘못된 중복 헤더 필드가 포함될 수 있기 때문에 요청 처리에 영향을 줄 수 있기 때문입니다.

	 [page 24] 메시지에서 발신자는 헤더 필드의 전체 필드 값이 쉼표로 구분된 목록으로 정의되었거나 헤더 필드가 잘 알려진 예외인 경우를 제외하고는 동일한 필드 이름으로 여러 헤더 필드를 생성해서는 안 됩니다(**"MUST NOT"**).

	 수신자는 동일한 필드 이름을 가진 여러 헤더 필드를 하나의 "field-name: field-value" 쌍으로 결합하여 메시지의 의미를 변경하지 않고, 각 후속 필드 값을 쉼표로 구분하여 결합된 필드 값에 추가할 수 있습니다. 따라서 동일한 필드 이름을 가진 헤더 필드가 수신되는 순서는 결합된 필드 값의 해석에 중요합니다. 프록시는 메시지를 전달할 때 이러한 필드 값의 순서를 변경해서는 안 됩니다.

	 참고: 실제로 응답 메시지에서는 "Set-Cookie" 헤더 필드([RFC6265])가 여러 번 나타나며 목록 구문을 사용하지 않으므로 동일한 이름을 가진 여러 헤더 필드에 대한 위의 요구 사항을 위반합니다. 단일 필드 값으로 결합할 수 없기 때문에 수신자는 헤더 필드를 처리하는 동안 "Set-Cookie"를 특별한 경우로 처리해야 합니다. (자세한 내용은 [Kri2001]의 부록 A.2.3을 참조하십시오.)

	**3.2 (3) Whitespace**
	
	 이 사양에서는 선형 공백 사용을 나타내는 세 가지 규칙을 사용합니다: OWS (선택적 공백), RWS (필수 공백) 및 BWS ("나쁜" 공백).

	 OWS 규칙은 선형 공백 옥텟이 나타날 수 있는 경우에 사용됩니다. 가독성을 향상시키기 위해 선택적인 공백이 선호되는 프로토콜 요소에서는 송신자는 선택적 공백을 하나의 SP로 생성해야 합니다(**"SHOULD"**). 그 외의 경우에는 송신자는 잘못된 또는 원하지 않는 프로토콜 요소를 희석시키기 위해 필요한 경우를 제외하고 선택적 공백을 생성하지 않아야 합니다("**SHOULD NOT**").

	 RWS 규칙은 적어도 하나의 선형 공백 옥텟이 필요한 필드 토큰을 구분하는 데 사용됩니다. 송신자는 RWS를 하나의 SP로 생성해야 합니다("**SHOULD**").

	 BWS 규칙은 **문법적(historical)** 으로 선택적 공백이 허용되는 경우에만 사용됩니다. 발신자는 메시지에서 BWS를 생성해서는 안 됩니다("**MUST NOT**"). 수신자는 이러한 잘못된 공백을 구문 분석하고 프로토콜 요소를 해석하기 전에 제거해야 합니다.

     OWS            = * ( SP / HTAB )
                    ; optional whitespace
     RWS            = 1*( SP / HTAB )
                    ; required whitespace
     BWS            = OWS
                    ; "bad" whitespace


	**3.2 (4) Field Parsing**

	 [page 25] 메시지는 개별 헤더 필드 이름과 독립적인 일반 알고리즘을 사용하여 구문 분석됩니다. 주어진 필드 값 내용은 메시지 해석의 나중 단계에서 (일반적으로 메시지의 전체 헤더 섹션이 처리된 후) 구문 분석됩니다. 따라서 이 사양은 이전 버전에서 "Field-Name: Field Value" 쌍을 정의하는 데 ABNF 규칙을 사용하지 않습니다. 대신, 이 사양은 각 등록된 필드 이름에 따라 이름이 지정된 ABNF 규칙을 사용합니다. 여기서 규칙은 해당 필드의 해당 필드 값에 대한 유효한 문법을 정의합니다 (즉, 일반 필드 구문 분석기에 의해 헤더 섹션에서 필드 값이 추출된 후).

	 