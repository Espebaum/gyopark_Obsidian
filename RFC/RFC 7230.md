
	하이퍼텍스트 전송 프로토콜 (HTTP/1.1) : 메세지 구문과 라우팅

* 서문

	하이퍼 텍스트 전송 프로토콜(http)는 분산된, 협력적인 하이퍼 텍스트 정보 시스템을 위한 국적 없는 응용 프로그램 수준의 프로토콜입니다. 이 문서는 HTTP 구조에 대한 개요를 제공하고, 그와 관련된 용어, "http" 그리고 "https" 통합 자원 식별자 제도, HTTP/1.1 메세지 구문과 요구되는 파싱 처리를 정의하며 구현과 관련된 보안 사항을 기술합니다.

1. **Introduction**

	하이퍼텍스트 전송 프로토콜(HTTP)은 국적 없는 응용 프로그램 수준의 요청/응답 프로토콜로, 확장 가능한 의미론과 자기 서술적인 메시지 페이 로드(payload)를 사용하여 네트워크 기반 하이퍼 텍스트 정보 시스템과 유연한 상호 작용을 가능하게 합니다. 이 문서는 HTTP/1.1 사양을 형성하는 일련의 문서 중 첫 번째 문서입니다.

	1. 메세지 구문과 라우팅 (이 문서 RFC 7230)
	2. 의미론과 그 내용 (RFC 7231)
	3. 조건적 요청 (RFC 7232)
	4. 범위 요청 (RFC 7233)
	5. 캐싱 (RFC 7234)
	6. 인증 (RFC 7235)

  
	이 HTTP/1.1 사양은 RFC 2616 및 RFC 2145(HTTP 버전 지정에 대한)을 폐기합니다. 이 사양은 또한 이전에 RFC 2817에서 정의된 터널을 설정하기 위한 CONNECT의 사용을 업데이트하고, RFC 2818에서 비공식적으로 설명된 "https" URI 체계를 정의합니다.

	HTTP는 정보 시스템을 위한 범용 인터페이스 프로토콜입니다. 이는 서비스의 구현 세부 정보를 숨기기 위해 설계되어 클라이언트에게 제공되는 리소스의 유형과 독립적인, 일관된 인터페이스를 제공합니다. 마찬가지로 서버는 각 클라이언트의 목적을 알 필요가 없습니다. HTTP 요청은 특정 유형의 클라이언트나 사전에 정의된 응용 프로그램 단계의 일부로 연관되는 것이 아니라, 독립적으로 고려될 수 있습니다. **결과적으로, 이는 다양한 맥락에서 효과적으로 사용할 수 있는 프로토콜이며, 구현은 시간이 지남에 따라 독립적으로 진화할 수 있습니다.**

	HTTP는 또한 비-HTTP 정보 시스템과의 통신을 번역하기 위한 중개 프로토콜로 설계되었습니다. HTTP 프록시 및 게이트웨이는 다양한 프로토콜을 하이퍼텍스트 형식으로 변환하여 클라이언트가 HTTP 서비스와 동일한 방식으로 볼 수 있고 조작할 수 있도록 함으로써 대체 정보 서비스에 대한 액세스를 제공할 수 있습니다.

	이 유연성의 한 가지 결과는 프로토콜을 인터페이스 뒤에서 발생하는 측면으로 정의할 수 없다는 점입니다. 대신, 우리는 통신의 구문, 수신된 통신의 의도, 그리고 수신자의 예상 동작을 정의하는 데 제한됩니다. 통신이 독립적으로 고려된다면, 성공적인 동작은 서버가 제공하는 관찰 가능한 인터페이스에 해당 변경 사항이 반영되어야 합니다. 그러나 여러 클라이언트가 동시에 작업하고 때로는 상충하는 목적으로 작동할 수 있기 때문에, 이러한 변경 사항이 단일 응답의 범위를 벗어나서 관찰 가능하도록 요구할 수는 없습니다.
	
	이 문서는 HTTP에서 사용되거나 언급되는 아키텍처 요소를 설명하고, "http" 및 "https" URI 체계를(**scheme, 프로토콜**) 정의하며, 전체적인 네트워크 운영 및 연결 관리를 설명하며, HTTP 메시지 프레임 및 전달 요구 사항을 정의합니다. 우리의 목표는 메시지 의미론과 독립적인 HTTP 메시지 처리에 필요한 모든 메커니즘을 정의함으로써 메시지 파서 및 메시지 전달 중개자의 완전한 요구 사항 집합을 정의하는 것입니다.

	**1.1. 요청 표기법**

	- "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", "OPTIONAL" 과 같은 단어는 다음과 같이 기술됩니다.

	- MUST: 이 단어 또는 "REQUIRED" 또는 "SHALL"이라는 용어는 해당 정의가 사양의 절대 요구사항임을 의미합니다.  
	- MUST NOT: 이 구문 또는 "SHALL NOT"라는 구문은 해당 정의가 사양의 절대적인 금지사항임을 의미합니다.
	- SHOULD: 이 단어 또는 "RECOMMENDED"라는 형용사는 특정 상황에서는 특정 항목을 무시할 수 있는 유효한 이유가 존재할 수 있지만, 다른 방식을 선택하기 전에 모든 영향을 이해하고 신중히 고려해야 함을 의미합니다.
	- SHOULD NOT: 이 구문 또는 "NOT RECOMMENDED"라는 구문은 특정 상황에서는 특정 동작이 허용되거나 심지어 유용할 수 있는 유효한 이유가 존재할 수 있지만, 모든 영향을 이해하고 사례를 신중히 고려해야 함을 의미합니다. 이 레이블로 설명된 동작을 구현하기 전에 해당 동작의 전체적인 영향을 이해하고 사례를 신중히 고려해야 합니다.
	- MAY: 이 단어 또는 "OPTIONAL"이라는 형용사는 항목이 실제로 선택 사항임을 의미합니다. 특정 시장 요구사항을 충족시키기 위해 또는 제품을 향상시키는 데 도움이 될 것으로 생각되기 때문에 한 공급업체는 해당 항목을 포함할 수 있으며, 다른 공급업체는 동일한 항목을 생략할 수 있습니다. 특정 옵션을 포함하지 않는 구현은 해당 옵션을 포함하는 다른 구현과 상호 운용될 수 있어야 합니다. 다만 기능이 제한될 수는 있습니다. 마찬가지로, 특정 옵션을 포함하는 구현은 해당 옵션을 포함하지 않는 다른 구현과 상호 운용될 수 있어야 합니다(물론 해당 옵션이 제공하는 기능은 제외됩니다).

	* 부합하는 기준과 에러 처리에 대한 고려는 섹션 2.5에 정의되어 있습니다.

	**1.2. 구문 표기**

	- 이 사양은 [RFC5234]의 확장된 Backus-Naur Form (ABNF) 표기법을 사용합니다. 이 표기법은 Section 7에서 정의된 목록 확장을 포함하고 있으며, '#' 연산자를 사용하여 쉼표로 구분된 목록을 간결하게 정의할 수 있도록 합니다. (이는 ** 연산자가 반복을 나타내는 방식과 유사합니다). 부록 B에는 모든 목록 연산자가 표준 ABNF 표기법으로 확장된 수집된 문법이 표시되어 있습니다.

	* 다음의 핵심 규칙은 [RFC5234], 부록 B.1에 정의된 대로 참조로 포함됩니다: ALPHA (문자), CR (캐리지 리턴), CRLF (CR LF), CTL (제어문자), DIGIT (10진수 0-9), DQUOTE (이중 인용부호), HEXDIG (16진수 0-9/A-F/a-f), HTAB (수평 탭), LF (줄 바꿈), OCTET (8비트 데이터 시퀀스), SP (공백), 그리고 VCHAR (가시적인 [USASCII] 문자).

	* 관례적으로, "obs-"로 접두사가 붙은 ABNF 규칙 이름은 역사적인 이유로 인해 나타나는 "폐기된" 문법 규칙을 나타냅니다.

2. **Architecture**

	HTTP는 World Wide Web (WWW) 아키텍처를 위해 만들어졌으며, 시간이 흐름에 따라 전 세계 하이퍼텍스트 시스템의 확장성 요구 사항을 지원하기 위해 발전해 왔습니다. 그 아키텍처의 많은 부분이 HTTP를 정의하는 용어와 구문 생성물에 반영되고 있습니다.

	**2.1 클라이언트 / 서버 메세징**

	 HTTP는 신뢰할 수 있는 전송 또는 세션 계층의 "연결"(Section 6)을 통해 메시지(Section 3)를 교환하여 동작하는 국적 없는 요청/응답 프로토콜입니다. **HTTP "클라이언트"는 하나 이상의 HTTP 요청을 보내기 위해 서버와의 연결을 설정하는 프로그램입니다. HTTP "서버"는 HTTP 응답을 보내어 HTTP 요청을 처리하기 위해 연결을 수락하는 프로그램입니다.**
  
	"클라이언트"와 "서버"라는 용어는 이러한 프로그램들이 특정 연결에서 **수행하는 역할**에 대해서만 언급합니다. 동일한 프로그램이 어떤 연결에서는 클라이언트로 동작하고 어떤 연결에서는 서버로 동작할 수 있습니다. "유저 에이전트(UA)"라는 용어는 요청을 시작하는 다양한 클라이언트 프로그램을 의미하며, 브라우저, 스파이더 (웹 기반 로봇), 명령 줄 도구, 사용자 정의 애플리케이션 및 모바일 앱을 포함하지만 이에 국한되지는 않습니다. "원본 서버"라는 용어는 특정 대상 리소스에 대해 권위 있는 응답을 생성할 수 있는 프로그램을 가리킵니다. "송신자"와 "수신자"라는 용어는 각각 주어진 메시지를 송신하거나 수신하는 구현을 의미합니다.
 
	HTTP는 리소스의 대상을 나타내기 위해 Uniform Resource Identifier (URI) 표준 [RFC3986]을 사용하며, 리소스 간의 관계를 나타냅니다. 메시지는 인터넷 메일 [RFC5322]과 Multipurpose Internet Mail Extensions (MIME) [RFC2045]에서 사용되는 형식과 유사한 형식으로 전달됩니다. HTTP와 MIME 메시지의 차이점에 대해서는 [RFC7231]의 부록 A를 참조하십시오.
	
	대부분의 HTTP 통신은 URI로 식별된 어떤 리소스의 표현을 검색하기 위한 검색 요청(GET)으로 이루어집니다. 가장 간단한 경우에는 **유저 에이전트** **(UA)** 와 **원본 서버** (O) 간에 단일 양방향 연결( === )을 통해 이를 수행할 수 있습니다.

		   request >
       UA ======================================= O
                                   < response

	**클라이언트**는 요청 메시지 형식으로 서버에 HTTP 요청을 보냅니다. 이 요청 메시지는 **요청 라인(request-line)** 으로 시작하며, 이는 메서드, URI 및 프로토콜 버전 (Section 3.1.1)을 포함합니다. 이후에는 요청 수정자, 클라이언트 정보 및 표현 메타데이터를 포함하는 **헤더 필드** (Section 3.2)가 이어지고, 헤더 섹션의 끝을 나타내는 빈 줄이 옵니다. 마지막으로, **메시지 본문**에는 페이로드 본문이 포함될 수 있습니다 (있는 경우, Section 3.3).

	**서버**는 클라이언트의 요청에 대해 하나 이상의 HTTP 응답 메시지를 보내어 응답합니다. 각 응답 메시지는 **상태 라인(status-line)** 으로 시작하며, 이는 프로토콜 버전, 성공 또는 오류 코드 및 텍스트 형식의 **이유 구문(reason phrase)** (Section 3.1.2)을 포함합니다. 이후에는 서버 정보, 리소스 메타데이터 및 표현 메타데이터를 포함하는 **헤더 필드 (Section 3.2)** 가 이어지고, 헤더 섹션의 끝을 나타내는 빈 줄이 옵니다. 마지막으로, **메시지 본문**에는 페이로드 본문이 포함될 수 있습니다 (있는 경우, Section 3.3).

	섹션 6.3에서 정의된대로

	다음 예제는 "[http://www.example.com/hello.txt](http://www.example.com/hello.txt)" URI에 대한 일반적인 GET 요청 (Section 4.3.1 of [RFC7231])에 대한 메시지 교환을 보여줍니다:
	
	**클라이언트 요청:**
	
	GET /hello.txt HTTP/1.1 
	User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3 
	Host: [www.example.com](http://www.example.com/) 
	Accept-Language: en, mi
	
	**서버 응답:**
	
	HTTP/1.1 200 OK 
	Date: Mon, 27 Jul 2009 12:28:53 GMT 
	Server: Apache 
	Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT 
	ETag: "34aa387-d-1568eb00" 
	Accept-Ranges: bytes 
	Content-Length: 51 
	Vary: Accept-Encoding 
	Content-Type: text/plain
	
	Hello World! My payload includes a trailing CRLF.

	**2.2. 구현 다양성**
	
	HTTP의 설계를 고려할 때, 모든 유저 에이전트가 일반적인 웹 브라우저이고 모든 출처 서버가 대형 공개 웹사이트인 것으로 생각하기 쉽습니다. 그러나 실제로는 그렇지 않습니다. 일반적인 HTTP 유저 에이전트에는 가전제품, 스테레오, 저울, 펌웨어 업데이트 스크립트, 명령줄 프로그램, 모바일 앱 및 다양한 모양과 크기의 통신 장치 등이 포함됩니다. 마찬가지로, 일반적인 HTTP 출처 서버에는 홈 자동화 장치, 구성 가능한 네트워킹 구성 요소, 사무 기기, 자율 로봇, 뉴스 피드, 교통 카메라, 광고 선택기 및 비디오 전송 플랫폼이 포함됩니다.

	"유저 에이전트"라는 용어는 요청이 발생할 때 인간 사용자가 소프트웨어 에이전트와 직접 상호작용하는 것을 의미하지 않습니다. 많은 경우 유저 에이전트는 백그라운드에서 실행되거나 구성되어 나중에 결과를 검사하기 위해 저장됩니다 (또는 흥미로운 또는 오류가 될 수 있는 결과의 일부분만 저장됩니다). 예를 들어, 스파이더는 일반적으로 시작 URI를 지정하고 웹을 탐색하는 동안 특정 동작을 따르도록 구성됩니다.

	HTTP의 구현 다양성은 모든 유저 에이전트가 사용자에게 대화식 제안을 제공하거나 보안 또는 개인 정보 보호에 대한 적절한 경고를 제공할 수 있는 것은 아니라는 것을 의미합니다. 이 명세에서 오류를 사용자에게 보고해야 하는 몇 가지 경우에는 해당 보고가 오류 콘솔이나 로그 파일에서만 관찰될 수 있는 것으로 허용됩니다. 마찬가지로, 자동화된 동작을 진행하기 전에 사용자로부터 확인이 필요한 요구 사항은 사전 구성 선택, 실행 시 옵션 또는 해당 위험한 동작을 피하는 간단한 조치로 충족될 수 있습니다. 확인은 특정 사용자 인터페이스나 정상 처리의 중단을 의미하지 않으며, 사용자가 이미 해당 선택을 했다면 정상 처리가 진행될 수 있습니다.

	**2.3 중재자들**

	  HTTP는 연결 체인을 통해 중개자를 사용하여 요청을 충족시키는 기능을 제공합니다. HTTP 중개자에는 프록시(proxy), 게이트웨이(gateway) 및 터널(tunnel)의 세 가지 일반적인 형태가 있습니다. 경우에 따라 단일 중개자가 각 요청의 성격에 따라 원 서버, 프록시, 게이트웨이 또는 터널로 작동할 수 있습니다.
         ->       ->      ->      ->
	 UA ===== A ===== B ===== C ===== O
	      <-       <-      <-      <-
	      
	위의 도표는 유저 에이전트와 원 서버 사이에 A, B, C라는 세 개의 중개자를 보여줍니다. 전체 체인을 통과하는 요청 또는 응답 메시지는 네 개의 별개의 연결을 통과합니다. 일부 HTTP 통신 옵션은 가장 가까운 터널이 아닌 이웃과의 연결에만 적용되거나 체인의 끝점에만 적용되거나 체인 전체의 모든 연결에 적용될 수 있습니다. 그림은 선형적이지만 각 참가자는 여러 개의 동시 통신에 참여할 수 있습니다. 예를 들어, B는 A 외에도 다른 클라이언트로부터 요청을 받거나 C 이외의 서버로 요청을 전달하면서 A의 요청을 처리하는 동시에 여러 개의 통신을 수행할 수 있습니다. 마찬가지로 나중의 요청은 로드 밸런싱을 위한 동적 구성에 따라 다른 연결 경로를 통해 전송될 수 있습니다.

	**"Upstream"** 과 **"downstream"** 이라는 용어는 메시지의 흐름과 관련하여 방향성 요구사항을 설명하는 데 사용됩니다. 모든 메시지는 "upstream"에서 "downstream"으로 흐릅니다. "Inbound"와 "outbound"라는 용어는 요청 경로와 관련하여 방향성 요구사항을 설명하는 데 사용됩니다. "Inbound"는 원 서버 쪽으로의 방향을 의미하며, 메시지가 처리를 위해 서버 쪽으로 이동하는 것을 나타냅니다. 반면에 "outbound"는 유저 에이전트 쪽으로의 방향을 의미하며, 메시지가 유저 에이전트 쪽으로 이동하여 소비되거나 표시되는 것을 나타냅니다.

	"**프록시(proxy)**"는 주로 로컬 설정 규칙을 경유하여, 클라이언트에 의해 선택되는 메시지 전달 에이전트로 일부 유형의 절대 URI를 요청 받고 HTTP 인터페이스를 통해 해당 요청을 만족시키기 위해 번역을 시도합니다. 일부 번역은 최소한으로 이루어지며, "http" URI에 대한 프록시 요청과 같은 경우입니다. 반면에 다른 요청은 완전히 다른 응용 계층 프로토콜로의 번역이 필요할 수도 있습니다. 프록시는 종종 보안, 주석 서비스 또는 공유 캐싱을 위해 조직의 HTTP 요청을 공통 중개자를 통해 그룹화하는 데 사용됩니다. 일부 프록시는 전달되는 동안 선택된 메시지나 페이로드에 변형을 적용하는 것이 설명된 섹션 5.7.2에서 설명된 대로 설계될 수 있습니다.
	![[local_configuration_rule.png]]

	 "게이트웨이" (또는 "리버스 프록시")는 외부 연결("outbound")의 출발지 서버 역할을 하는 중개자로, 받은 요청을 번역하여 내부로 전달합니다. 게이트웨이는 종종 레거시 시스템이나 신뢰할 수 없는 정보 서비스를 캡슐화하거나, "가속기" 캐싱을 통해 서버 성능을 향상시키는 데 사용되며, HTTP 서비스를 여러 기기에 분할하거나 부하 분산을 가능하게 합니다.

	"터널"은 메시지를 변경하지 않으면서 두 연결 사이에서 블라인드 중계 역할을 수행합니다. 터널은 일단 활성화되면 HTTP 통신의 일부로 간주되지는 않지만, 그 자체는 HTTP 요청에 의해 시작될 수 있습니다. 터널은 양측의 연속적인 통신이 끝날 때 종료됩니다. 터널은 공유 방화벽 프록시를 통해 기밀 통신을 설정하기 위해 전송 계층 보안(TLS, [RFC5246])을 사용할 때와 같이 중개자를 통해 가상 연결을 확장하는 데 사용됩니다.




